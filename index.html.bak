<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>R√©vision Grammaire</title>
  <link rel="stylesheet" href="style.css">
  <script>
  // Fonction pour m√©langer un tableau (algorithme de Fisher-Yates)
  function melangerTableau(tableau) {
    const resultat = [...tableau];
    for (let i = resultat.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [resultat[i], resultat[j]] = [resultat[j], resultat[i]];
    }
    return resultat;
  }
  
  // D√©finition de la fonction checkFutur en premier
  function checkFutur(answer, game = 'futur') {
    console.log('=== FONCTION checkFutur APPEL√âE ===');
    console.log('Bouton cliqu√©:', answer);
    
    // Attendre que l'objet games soit disponible
    if (!window.games) {
      console.error('L\'objet games n\'est pas encore charg√©');
      return;
    }
    
    const gameData = window.games[game];
    if (!gameData) {
      console.error('Jeu non trouv√©:', game, 'Disponibles:', Object.keys(window.games));
      return;
    }
    
    // V√©rifier que l'index actuel est valide
    if (typeof gameData.current === 'undefined' || gameData.current === null) {
      console.error('Index actuel non d√©fini, r√©initialisation...');
      gameData.current = 0;
    }
    
    let currentData = gameData.data[gameData.current];
    if (!currentData) {
      console.error('Aucune donn√©e pour la phrase actuelle. Index:', gameData.current, 'Donn√©es:', gameData.data);
      // Essayer de r√©cup√©rer la premi√®re phrase
      if (gameData.data.length > 0) {
        console.log('Tentative de r√©cup√©ration de la premi√®re phrase...');
        gameData.current = 0;
        currentData = gameData.data[0];
      } else {
        return;
      }
    }
    
    console.log('Index actuel:', gameData.current, '/', gameData.data.length - 1);
    console.log('Toutes les donn√©es:', gameData.data);
    
    console.log('Donn√©es de la phrase actuelle:', currentData);
    
    const feedbackElement = document.getElementById('futur-feedback');
    
    // V√©rifier la r√©ponse
    const expectedAnswer = currentData.type;
    console.log('R√©ponse attendue:', expectedAnswer, 'R√©ponse donn√©e:', answer);
    
    if (answer === expectedAnswer) {
      console.log('Bonne r√©ponse');
      feedbackElement.textContent = '‚úÖ Bonne r√©ponse ! +1 point';
      feedbackElement.style.color = 'green';
      gameData.totalPoints++;
    } else {
      console.log('Mauvaise r√©ponse');
      feedbackElement.textContent = `‚ùå Faux ! La bonne r√©ponse √©tait "${expectedAnswer}" -1 point`;
      feedbackElement.style.color = 'red';
      
      // Enlever un point (mais ne pas descendre en dessous de 0)
      if (gameData.totalPoints > 0) {
        gameData.totalPoints--;
      }
      gameData.totalErreurs++;
      
      // Jouer un son d'erreur
      const sound = document.getElementById('sound-bad');
      if (sound) {
        sound.currentTime = 0;
        sound.play().catch(e => console.error('Erreur de lecture du son:', e));
      }
    }
    
    // Mettre √† jour le tableau des scores
    updateScoreboard(game);
    
    // D√©sactiver tous les boutons sauf suivant
    const buttons = document.querySelectorAll('.game-futur button');
    console.log('Boutons trouv√©s:', buttons.length);
    buttons.forEach(btn => {
      if (btn.id !== 'nextFutur') {
        btn.disabled = true;
      } else {
        btn.disabled = false;
      }
    });
    
    // Mettre √† jour le score
    if (window.updateScoreboard) {
      window.updateScoreboard(game);
    }
  }
  
  // Fonction pour charger les donn√©es du jeu futur depuis le fichier JSON
  function loadFuturData() {
    console.log('D√©but du chargement de futur.json...');
    return fetch('futur.json')
      .then(response => {
        console.log('R√©ponse re√ßue pour futur.json:', response.status, response.statusText);
        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status} ${response.statusText}`);
        }
        return response.json();
      })
      .then(data => {
        if (!data || !data.data || !Array.isArray(data.data)) {
          throw new Error('Format de donn√©es invalide dans futur.json');
        }
        console.log('Donn√©es brutes du futur charg√©es:', data);
        return data.data; // Retourne directement les donn√©es sans transformation
      })
      .catch(error => {
        console.error('Erreur lors du chargement des donn√©es du futur:', error);
      });
  }

  // Fonction pour charger les donn√©es du jeu roles
  async function loadRolesData() {
    console.log('D√©but du chargement de data.json...');
    try {
      const response = await fetch('data.json');
      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status} ${response.statusText}`);
      }
      const data = await response.json();
      console.log('Donn√©es du jeu roles charg√©es avec succ√®s');
      return data;
    } catch (error) {
      console.error('Erreur lors du chargement des donn√©es des r√¥les:', error);
      return [];
    }
  }

  // Fonction pour charger les donn√©es du jeu des temps
  async function loadTempsData() {
    console.log('D√©but du chargement de temps.json...');
    try {
      const response = await fetch('temps.json');
      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status} ${response.statusText}`);
      }
      const data = await response.json();
      console.log('Donn√©es du jeu des temps charg√©es avec succ√®s');
      return data.data || [];
    } catch (error) {
      console.error('Erreur lors du chargement des donn√©es des temps:', error);
      return [];
    }
  }

  // Fonction pour initialiser les jeux
  async function initGames() {
    if (!window.games) {
      // Initialiser la structure des jeux
      window.games = {
        roles: {
          data: [],
          current: 0,
          usedIndices: [],
          r√©ponsesCorrectes: new Set(),
          totalPoints: 0,
          totalErreurs: 0
        },
        futur: {
          data: [],
          current: 0,
          usedIndices: [],
          r√©ponsesCorrectes: new Set(),
          totalPoints: 0,
          totalErreurs: 0
        },
        temps: {
          data: [],
          current: 0,
          usedIndices: [],
          r√©ponsesCorrectes: new Set(),
          totalPoints: 0,
          totalErreurs: 0
        },
        definitions: {
          data: [],
          current: 0,
          usedIndices: [],
          r√©ponsesCorrectes: new Set(),
          totalPoints: 0,
          totalErreurs: 0
        }
      };
      
      // Charger les donn√©es des jeux en parall√®le
      try {
        const [rolesData, futurData, tempsData] = await Promise.all([
          loadRolesData(),
          loadFuturData(),
          loadTempsData()
        ]);
        
        // Mettre √† jour les donn√©es des jeux
        if (rolesData && rolesData.length > 0) {
          window.games.roles.data = rolesData;
          console.log('Donn√©es du jeu roles charg√©es avec succ√®s');
        } else {
          console.warn('Aucune donn√©e charg√©e pour le jeu roles');
        }
        
        if (futurData && futurData.length > 0) {
          window.games.futur.data = futurData;
          console.log('Donn√©es du jeu futur charg√©es avec succ√®s');
        } else {
          console.warn('Aucune donn√©e charg√©e pour le jeu futur');
        }
        
        if (tempsData && tempsData.length > 0) {
          window.games.temps.data = tempsData;
          console.log('Donn√©es du jeu des temps charg√©es avec succ√®s');
        } else {
          console.warn('Aucune donn√©e charg√©e pour le jeu des temps');
        }
        
      } catch (error) {
        console.error('Erreur lors du chargement des donn√©es:', error);
      }
      
      console.log('Jeux initialis√©s avec succ√®s');
    }
  }
  
  // Fonction pour d√©marrer l'application une fois le DOM charg√©
  async function startApp() {
    console.log('D√©marrage de l\'application...');
    
    try {
      // Initialiser les jeux et attendre qu'ils soient pr√™ts
      await initGames();
      
      // V√©rifier que les jeux sont correctement initialis√©s
      if (!window.games) {
        throw new Error('√âchec de l\'initialisation des jeux');
      }
      
      console.log('Jeux initialis√©s avec succ√®s:', Object.keys(window.games));
      console.log('Donn√©es du jeu futur:', window.games?.futur?.data);
      
      // S√©lectionner le jeu par d√©faut (roles)
      selectGame('roles');
      
      // Afficher un message de chargement termin√©
      console.log('Application pr√™te');
      
    } catch (error) {
      console.error('Erreur lors du d√©marrage de l\'application:', error);
      // Afficher un message d'erreur √† l'utilisateur
      const errorDiv = document.createElement('div');
      errorDiv.style.color = 'red';
      errorDiv.style.padding = '20px';
      errorDiv.style.textAlign = 'center';
      errorDiv.textContent = 'Une erreur est survenue lors du chargement de l\'application. Veuillez rafra√Æchir la page.';
      document.body.insertBefore(errorDiv, document.body.firstChild);
    }
  }
  
  // D√©marrer l'application une fois le DOM charg√©
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', startApp);
  } else {
    startApp();
  }
  </script>
</head>
<body>
  <div class="container">
    <button class="menu-btn" onclick="toggleMenu()">‚ò∞</button>
    <nav class="sidebar">
      <div class="logo">
        <h2>R√©vision Grammaire</h2>
      </div>
      <ul class="menu">
        <li class="active">
          <a href="#roles" onclick="selectGame('roles')">
            <span>üîç R√¥les des groupes</span>
          </a>
        </li>
        <li>
          <a href="#futur" onclick="selectGame('futur')">
            <span>üîÆ Futur simple</span>
          </a>
        </li>
        <li>
          <a href="#temps" onclick="selectGame('temps')">
            <span>‚è±Ô∏è Les temps</span>
          </a>
        </li>
        <li>
          <a href="#conjugaison" onclick="selectGame('conjugaison')">
            <span>üìù Conjugaison au futur</span>
          </a>
        </li>
        <li>
          <a href="#geometrie" onclick="selectGame('geometrie')">
            <span>üìê Formes g√©om√©triques</span>
          </a>
        </li>
        <li>
          <a href="#definitions" onclick="selectGame('definitions')">
            <span>üìñ D√©finitions de g√©om√©trie</span>
          </a>
        </li>
      </ul>
    </nav>
  <main class="main-content">
    <div class="top-bar">
      <div id="scoreboard">
        Points : <span id="points">0</span> | Erreurs : <span id="errors">0</span>
        <div class="stars" id="stars"></div>
      </div>
      <button onclick="resetScores()">üîÑ R√©initialiser</button>
    </div>

    <div class="game-content">
      <div class="game-roles">
        <h1>Quel est le r√¥le de chaque groupe ?</h1>
        <div class="phrase" id="phrase">Chargement de la phrase...</div>
        <div>
          <button onclick="checkAnswer('sujet')">üîµ Sujet</button>
          <button onclick="checkAnswer('verbe')">üî¥ Verbe</button>
          <button onclick="checkAnswer('cdv')">üî¥ GCDV</button>
          <button onclick="checkAnswer('civ')">üî¥ GCIV</button>
        </div>
        <p id="feedback"></p>
        <button id="nextBtn" onclick="nextPhrase()" disabled>üëâ Phrase suivante</button>
      </div>
      <div class="game-futur" style="display: none;">
        <h1>Conjugaison au futur simple</h1>
        <div class="futur-content">
          <div class="futur-phrase" id="futur-phrase">Chargement de la phrase...</div>
          <div>
            <button onclick="checkFutur('√™tre')">üîµ √™tre</button>
            <button onclick="checkFutur('avoir')">üî¥ avoir</button>
            <button onclick="checkFutur('er')">üîµ -er</button>
            <button onclick="checkFutur('ir')">üî¥ -ir</button>
          </div>
          <p id="futur-feedback"></p>
          <button id="nextFutur" onclick="nextPhrase('futur')" disabled>üëâ Phrase suivante</button>
        </div>
      </div>
      <div class="game-temps" style="display: none;">
        <h1>Analyse du verbe</h1>
        <div class="temps-content">
          <div class="temps-phrase" id="temps-phrase">Chargement de la phrase...</div>
          
          <div class="input-group">
            <label for="infinitif-input">Infinitif du verbe :</label>
            <input type="text" id="infinitif-input" placeholder="Entrez l'infinitif du verbe">
          </div>
          
          <div class="input-group">
            <label>Temps du verbe :</label>
            <div class="button-group">
              <button onclick="selectAndCheckTemps('pass√©')">‚èÆÔ∏è Pass√©</button>
              <button onclick="selectAndCheckTemps('pr√©sent')">‚èØÔ∏è Pr√©sent</button>
              <button onclick="selectAndCheckTemps('futur')">‚è≠Ô∏è Futur</button>
            </div>
          </div>
          
          <p id="temps-feedback"></p>
          <button id="nextTemps" onclick="nextPhrase('temps')" class="next-btn" disabled>üëâ Phrase suivante</button>
        </div>
      </div>

      <!-- Jeu de g√©om√©trie -->
      <div class="game-geometrie" style="display: none;">
        <h1>Formes g√©om√©triques</h1>
        <div class="geometrie-container">
          <div class="niveau-selection">
            <h2>Choisis un niveau</h2>
            <div class="niveaux-boutons">
              <button class="niveau-btn" data-niveau="polygone-ou-non">Polygone ou non ?</button>
              <button class="niveau-btn" data-niveau="type-polygone">Type de polygone</button>
            </div>
          </div>
          
          <div class="jeu-interface" style="display: none;">
            <div class="niveau-description">
              <h2 id="niveau-titre"></h2>
              <p id="niveau-description"></p>
            </div>
            
            <div id="forme-container">
              <div id="forme-image"></div>
              <div id="forme-options"></div>
              <div class="boutons-actions">
                <button id="btn-valider">Valider</button>
                <button id="btn-suivant" style="display: none;">Suivant</button>
                <button id="recommencer">Recommencer</button>
              </div>
            </div>
            
            <div id="resultats">
              <h3>R√©sultats</h3>
              <p>Score: <span id="score">0</span>/<span id="total">0</span></p>
              <p id="feedback"></p>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Jeu de conjugaison au futur -->
      <div class="game-conjugaison" style="display: none;">
        <h1>Conjugaison au futur</h1>
        <div class="score-conjugaison">
          Score: <span id="score-conjugaison">0</span> / <span id="total-verbes">0</span>
        </div>
        <div class="conjugaison-content">
          <div class="conjugaison-header">
            <div class="conjugaison-verbe" id="conjugaison-verbe">Conjuguez le verbe : <span id="verbe-infinitif">chargement...</span></div>
            <div class="verbe-compteur" id="verbe-compteur">1/0</div>
          </div>
          
          <div class="conjugaison-grid">
            <div class="conjugaison-row">
              <label>Je</label>
              <input type="text" id="conj-je" data-personne="je" class="conjugaison-input">
              <span id="result-je" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Tu</label>
              <input type="text" id="conj-tu" data-personne="tu" class="conjugaison-input">
              <span id="result-tu" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Il/Elle/On</label>
              <input type="text" id="conj-il" data-personne="il" class="conjugaison-input">
              <span id="result-il" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Nous</label>
              <input type="text" id="conj-nous" data-personne="nous" class="conjugaison-input">
              <span id="result-nous" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Vous</label>
              <input type="text" id="conj-vous" data-personne="vous" class="conjugaison-input">
              <span id="result-vous" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Ils/Elles</label>
              <input type="text" id="conj-ils" data-personne="ils" class="conjugaison-input">
              <span id="result-ils" class="conjugaison-result"></span>
            </div>
          </div>
          
          <div class="conjugaison-actions">
            <button id="check-conjugaison" class="check-btn">V√©rifier les r√©ponses</button>
            <button id="next-conjugaison" class="next-btn" disabled>Verbe suivant</button>
          </div>
          
          <div id="conjugaison-feedback" class="conjugaison-feedback"></div>
        </div>
      </div>

      <!-- Jeu de g√©om√©trie -->
      <div class="game-geometrie" style="display: none;">
        <h1>D√©couverte des formes g√©om√©triques</h1>
        <p class="niveau-description">S√©lectionne un niveau pour commencer √† jouer !</p>
        
        <div class="geometrie-niveaux">
          <button class="niveau-btn" data-niveau="polygone-ou-non">Niveau 1 : Polygone ou non ?</button>
          <button class="niveau-btn" data-niveau="type-polygone">Niveau 2 : Type de polygone</button>
          <button class="niveau-btn" data-niveau="quadrilateres">Niveau 3 : Les quadrilat√®res</button>
          <button class="niveau-btn" data-niveau="definitions">Apprendre les d√©finitions</button>
        </div>
        
        <div class="forme-container" id="forme-container" style="display: none;">
          <h2 id="niveau-titre"></h2>
          <p id="niveau-description"></p>
          
          <div class="forme-image" id="forme-image">
            <!-- L'image de la forme sera ins√©r√©e ici par JavaScript -->
          </div>
          
          <div class="reponse-boutons" id="reponse-boutons-container" style="
            border: 2px solid red; 
            padding: 20px; 
            margin: 20px 0;
            background-color: #f9f9f9;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 100px;
            position: relative;
          ">
            <!-- Les boutons de r√©ponse seront g√©n√©r√©s dynamiquement -->
            <p style="
              color: red; 
              font-style: italic;
              position: absolute;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              margin: 0;
              opacity: 0.5;
              text-align: center;
              display: none; /* Cach√© par d√©faut, affich√© uniquement si aucun bouton n'est ajout√© */
            " id="message-aucun-bouton">
              Aucun bouton de r√©ponse n'a √©t√© g√©n√©r√©
            </p>
          </div>
          
          <div class="feedback" id="feedback">
            <p id="feedback-texte"></p>
            <p id="explication"></p>
          </div>
          
          <div class="definition" id="definition" style="display: none;">
            <h3>D√©finition :</h3>
            <p id="definition-texte"></p>
          </div>
          
          <div class="actions">
            <button class="btn btn-primary" id="btn-valider" disabled>Valider</button>
            <button class="btn btn-primary" id="btn-suivant" style="display: none;">Forme suivante</button>
          </div>
        </div>
        
        <div id="resultats" style="text-align: center; margin-top: 20px; display: none;">
          <h3>R√©sultats</h3>
          <p>Score : <span id="score">0</span> / <span id="total">0</span></p>
          <button class="btn btn-primary" id="recommencer">Recommencer</button>
        </div>
      </div>
      
      <!-- D√©but du jeu de d√©finitions -->
      <div id="jeu-definitions" style="display: none;">
        <h2>Associe chaque d√©finition √† la bonne forme</h2>
        <div class="definitions-score">
          Score : <span id="score-definitions">0</span> / <span id="total-definitions">0</span>
        </div>
        <div class="definitions-container">
          <div class="definitions-list" id="definitions-list">
            <!-- Les d√©finitions seront ajout√©es ici dynamiquement -->
          </div>
          <div class="shapes-container" id="shapes-container">
            <!-- Les formes seront ajout√©es ici dynamiquement -->
          </div>
        </div>
        <div class="feedback-def" id="feedback-def"></div>
        <div class="definitions-buttons">
          <button class="btn btn-primary" id="verifier-def">V√©rifier</button>
          <button class="btn btn-primary" id="suivant-def" style="display: none;">D√©finition suivante</button>
        </div>
      </div>
      <!-- Fin du jeu de d√©finitions -->
      
    </div>
    <audio id="sound-bad" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg"></audio>
  </main>

<script>
let currentGame = 'roles'; // Game par d√©faut
let selected = null; // Variable pour stocker le mot s√©lectionn√©

// Variables pour le jeu de conjugaison
let currentVerbe = null;
let verbesData = [];
let currentVerbeIndex = 0;
let games = {
  roles: {
    data: [],
    current: 0,
    usedIndices: [],
    r√©ponsesCorrectes: new Set(),
    totalPoints: 0,
    totalErreurs: 0
  },
  futur: {
    data: [],
    current: 0,
    usedIndices: [],
    r√©ponsesCorrectes: new Set(),
    totalPoints: 0,
    totalErreurs: 0
  }
};

// Charger les donn√©es des r√¥les depuis le fichier JSON
fetch('./data.json')
  .then(response => response.json())
  .then(rolesData => {
    if (rolesData && Array.isArray(rolesData) && rolesData.length > 0) {
      games.roles.data = rolesData;
      selectGame('roles'); // Charger le jeu par d√©faut apr√®s le chargement des donn√©es
    } else {
      console.error('Donn√©es des r√¥les invalides ou manquantes');
      document.getElementById('phrase').textContent = 'Erreur : Donn√©es des r√¥les manquantes.';
    }
  })
  .catch(err => {
    console.error('Erreur de chargement des donn√©es des r√¥les:', err);
    document.getElementById('phrase').textContent = 'Erreur : Impossible de charger les donn√©es des r√¥les.';
  });

// Charger les donn√©es du futur depuis le fichier JSON
fetch('futur.json')
  .then(response => {
    if (!response.ok) {
      throw new Error(`Erreur HTTP: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    if (data && data.data && Array.isArray(data.data)) {
      games.futur.data = data.data;
      console.log('Donn√©es du futur charg√©es avec succ√®s:', games.futur.data);
    } else {
      throw new Error('Format de donn√©es invalide dans futur.json');
    }
  })
  .catch(error => {
    console.error('Erreur lors du chargement du fichier futur.json:', error);
  });

// Ajouter les gestionnaires d'√©v√©nements pour les boutons du futur
document.addEventListener('DOMContentLoaded', function() {
  // Charger les donn√©es du jeu de d√©finitions
  fetch('definitions.json')
    .then(response => {
      if (!response.ok) {
        throw new Error('Erreur de chargement des d√©finitions');
      }
      return response.json();
    })
    .then(data => {
      window.definitionsData = data.definitions;
      console.log('Donn√©es des d√©finitions charg√©es:', window.definitionsData);
    })
    .catch(error => {
      console.error('Erreur lors du chargement des d√©finitions:', error);
      document.getElementById('jeu-definitions').innerHTML = 
        '<p class="error">Erreur de chargement des d√©finitions. Veuillez recharger la page.</p>';
    });
    
  console.log('Ajout des gestionnaires d\'√©v√©nements pour les boutons du futur');
  
  // Gestionnaire pour le bouton √™tre
  const btnEtre = document.querySelector('button[onclick*="checkFutur(\'√™tre\')"]');
  if (btnEtre) {
    console.log('Bouton √™tre trouv√©');
    btnEtre.onclick = function() { checkFutur('√™tre'); };
  }
  
  // Gestionnaire pour le bouton avoir
  const btnAvoir = document.querySelector('button[onclick*="checkFutur(\'avoir\')"]');
  if (btnAvoir) {
    console.log('Bouton avoir trouv√©');
    btnAvoir.onclick = function() { checkFutur('avoir'); };
  }
  
  // Gestionnaire pour le bouton -er
  const btnEr = document.querySelector('button[onclick*="checkFutur(\'er\')"]');
  if (btnEr) {
    console.log('Bouton -er trouv√©');
    btnEr.onclick = function() { checkFutur('er'); };
  }
  
  // Gestionnaire pour le bouton -ir
  const btnIr = document.querySelector('button[onclick*="checkFutur(\'ir\')"]');
  if (btnIr) {
    console.log('Bouton -ir trouv√©');
    btnIr.onclick = function() { checkFutur('ir'); };
  }
  
  // Gestionnaire pour le bouton V√©rifier du jeu de d√©finitions
  const btnVerifierDef = document.getElementById('verifier-def');
  if (btnVerifierDef) {
    btnVerifierDef.addEventListener('click', verifierReponseDefinition);
  }
  
  // Gestionnaire pour le bouton Suivant du jeu de d√©finitions
  const btnSuivantDef = document.getElementById('suivant-def');
  if (btnSuivantDef) {
    btnSuivantDef.addEventListener('click', afficherDefinitionSuivante);
  }
});

// Le chargement du jeu par d√©faut est maintenant g√©r√© dans startApp()

function selectGame(game) {
  console.log('S√©lection du jeu:', game);
  
  // Fermer le menu sur mobile/tablette
  if (window.innerWidth <= 1024) {
    const sidebar = document.querySelector('.sidebar');
    if (sidebar) {
      sidebar.classList.remove('active');
    }
  }
  
  // Masquer tous les jeux
  document.querySelectorAll('.game-content > div, #jeu-definitions').forEach(el => {
    el.style.display = 'none';
  });
  
  // R√©initialiser le jeu actuel
  resetGame(game);
  
  // Afficher le jeu s√©lectionn√©
  if (game === 'futur') {
    document.querySelector('.game-futur').style.display = 'block';
    currentGame = 'futur';
    nextPhrase('futur');
  } else if (game === 'roles') {
    document.querySelector('.game-roles').style.display = 'block';
    currentGame = 'roles';
    nextPhrase('roles');
  } else if (game === 'temps') {
    document.querySelector('.game-temps').style.display = 'block';
    currentGame = 'temps';
    nextPhrase('temps');
  } else if (game === 'conjugaison') {
    document.querySelector('.game-conjugaison').style.display = 'block';
    currentGame = 'conjugaison';
    initConjugaison();
  } else if (game === 'geometrie') {
    document.querySelector('.game-geometrie').style.display = 'block';
    currentGame = 'geometrie';
    initialiserJeuGeometrie();
  } else if (game === 'definitions') {
    const definitionsGame = document.getElementById('jeu-definitions');
    if (definitionsGame) {
      definitionsGame.style.display = 'block';
      currentGame = 'definitions';
      initialiserJeuDefinitions();
    } else {
      console.error('√âl√©ment du jeu de d√©finitions non trouv√©');
    }
  }
  
  // Mettre √† jour le menu
  document.querySelectorAll('.sidebar a').forEach(link => {
    link.classList.remove('active');
  });
  document.querySelector(`.sidebar a[onclick*="${game}"]`).classList.add('active');
  
  // Fermer le menu mobile si ouvert
  document.querySelector('.sidebar').classList.remove('active');
}

function resetGame(game = currentGame) {
  console.log(`R√©initialisation du jeu: ${game}`);
  
  const gameData = window.games?.[game];
  if (!gameData) {
    console.error('Impossible de r√©initialiser: jeu non trouv√©:', game);
    return;
  }
  
  // R√©initialiser les scores et l'√©tat
  gameData.totalPoints = 0;
  gameData.totalErreurs = 0;
  gameData.usedIndices = [];
  
  // Pour le jeu des r√¥les, r√©initialiser les r√©ponses correctes
  if (game === 'roles') {
    gameData.r√©ponsesCorrectes = new Set();
  }
  
  // S'assurer que current est d√©fini
  gameData.current = 0;
  
  console.log('Donn√©es du jeu apr√®s r√©initialisation:', gameData);
  
  // Ne pas appeler nextPhrase pour le jeu de d√©finitions car il utilise sa propre logique
  if (game !== 'definitions') {
    // Choisir une phrase al√©atoire pour les autres jeux
    nextPhrase(game);
  }
  
  // Mettre √† jour le score
  updateScoreboard(game);
  
  // R√©initialiser l'affichage
  if (game === 'futur') {
    const feedback = document.getElementById('futur-feedback');
    if (feedback) {
      feedback.textContent = '';
      feedback.style.color = '';
    }
  } else {
    const feedback = document.getElementById('feedback');
    if (feedback) {
      feedback.textContent = '';
    }
  }
  document.getElementById('nextBtn').disabled = true;
}

function updateScoreboard(game = currentGame) {
  if (!window.games || !window.games[game]) {
    console.error('Donn√©es du jeu non disponibles pour la mise √† jour du score');
    return;
  }
  
  const gameData = window.games[game];
  const pointsElement = document.getElementById('points');
  const errorsElement = document.getElementById('errors');
  const starsElement = document.getElementById('stars');
  
  if (pointsElement) pointsElement.textContent = gameData.totalPoints;
  if (errorsElement) errorsElement.textContent = gameData.totalErreurs;
  
  // Ajouter une √©toile par tranche de 10 points
  const starCount = Math.floor(Math.max(0, gameData.totalPoints) / 10);
  if (starsElement) {
    starsElement.textContent = '‚≠ê'.repeat(starCount);
    console.log(`Mise √† jour du score: ${gameData.totalPoints} points, ${starCount} √©toiles`);
  }
}

function renderPhrase(game = currentGame) {
  console.log(`Rendu de la phrase pour le jeu: ${game}`);
  
  if (!window.games) {
    console.error('Jeux non initialis√©s');
    return;
  }
  
  const gameData = window.games[game];
  if (!gameData) {
    console.error('Donn√©es du jeu non trouv√©es pour:', game, 'Disponibles:', Object.keys(window.games));
    return;
  }
  
  if (!gameData.data || !Array.isArray(gameData.data) || gameData.data.length === 0) {
    console.error('Aucune donn√©e de phrase disponible pour le jeu:', game);
    return;
  }
  
  if (typeof gameData.current === 'undefined' || !gameData.data[gameData.current]) {
    console.error('Index de phrase invalide:', gameData.current, 'pour le jeu:', game);
    return;
  }
  
  const phraseObj = gameData.data[gameData.current];
  console.log('Phrase actuelle:', phraseObj);
  
  // G√©rer le jeu des r√¥les
  if (game === 'roles') {
    const phraseTexte = phraseObj.phrase;
    let html = phraseTexte;
    document.getElementById('feedback').textContent = '';
    document.getElementById('nextBtn').disabled = true;
    gameData.r√©ponsesCorrectes = new Set();
    selected = null;

    // Remplace chaque groupe par un <span>
    if (phraseObj.groupes && Array.isArray(phraseObj.groupes)) {
      phraseObj.groupes.forEach((g, index) => {
        const escaped = g.texte.replace(/[.*+?^${}()|\\]/g, '\\$&');
        const pattern = new RegExp(escaped, 'i'); // ignore la casse
        html = html.replace(
          pattern,
          `<span class="mot" data-role="${g.role}" data-index="${index}">${g.texte}</span>`
        );
      });
    }

    const container = document.getElementById('phrase');
    container.innerHTML = html;

    container.querySelectorAll('.mot').forEach(span => {
      span.onclick = () => {
        if (span.classList.contains('bleu') || span.classList.contains('rouge')) return;
        document.querySelectorAll('.mot').forEach(m => m.classList.remove('selected'));
        selected = span;
        span.classList.add('selected');
        document.getElementById('feedback').textContent = '';
      };
    });
  }
  // G√©rer le jeu du futur simple
  else if (game === 'futur') {
    const container = document.getElementById('futur-phrase');
    if (!container) {
      console.error('√âl√©ment futur-phrase non trouv√©');
      return;
    }
    container.textContent = phraseObj.phrase || 'Phrase non disponible';
    
    const feedbackElement = document.getElementById('futur-feedback');
    if (feedbackElement) {
      feedbackElement.textContent = '';
      feedbackElement.style.color = '';
    }
    document.getElementById('nextFutur').disabled = true;
  }
  // G√©rer le jeu des temps
  else if (game === 'temps') {
    const container = document.getElementById('temps-phrase');
    if (!container) {
      console.error('√âl√©ment temps-phrase non trouv√©');
      return;
    }
    container.textContent = phraseObj.phrase || 'Phrase non disponible';
    
    const feedbackElement = document.getElementById('temps-feedback');
    if (feedbackElement) {
      feedbackElement.textContent = '';
      feedbackElement.style.color = '';
    }
    
    // R√©activer le champ de saisie et les boutons de r√©ponse
    const infinitifInput = document.getElementById('infinitif-input');
    if (infinitifInput) {
      infinitifInput.disabled = false;
      infinitifInput.value = ''; // R√©initialiser la valeur
    }
    
    // R√©activer les boutons de temps
    document.querySelectorAll('.game-temps .button-group button').forEach(btn => {
      btn.disabled = false;
    });
    
    // D√©s√©lectionner le temps pr√©c√©dent
    selectedTemps = null;
    
    // Les boutons de temps sont d√©j√† d√©sactiv√©s par d√©faut
    
    const nextBtn = document.getElementById('nextTemps');
    if (nextBtn) nextBtn.disabled = true;
  }
}

// La fonction checkFutur est maintenant d√©finie dans le <head> pour √™tre disponible imm√©diatement

function checkAnswer(answer, game = currentGame) {
  if (!selected) {
    alert("Clique sur un groupe de mots.");
    return;
  }

  const gameData = games[game];
  const role = selected.dataset.role;
  const idx = selected.dataset.index;
  selected.classList.remove('selected');

  if (answer === role) {
    selected.classList.add('bleu');
    document.getElementById('feedback').textContent = '‚úÖ Bonne r√©ponse !';
    gameData.r√©ponsesCorrectes.add(idx);
    gameData.totalPoints++;
  } else {
    selected.classList.add('rouge');
    document.getElementById('feedback').textContent = ' Mauvaise r√©ponse !';
    gameData.totalErreurs++;
    const sound = document.getElementById('sound-bad');
    sound.currentTime = 0;
    sound.play();
  }

  updateScoreboard(game);

  if (gameData.r√©ponsesCorrectes.size === gameData.data[gameData.current].groupes.length) {
    document.getElementById('nextBtn').disabled = false;
  }
}



function nextPhrase(game = currentGame) {
  if (!window.games) {
    console.error('Jeux non initialis√©s');
    return;
  }
  
  const gameData = window.games[game];
  if (!gameData) {
    console.error('Jeu non trouv√©:', game, 'Disponibles:', Object.keys(window.games));
    return;
  }
  
  console.log('Passage √† la phrase suivante. Indices utilis√©s:', gameData.usedIndices);
  
  // R√©activer les boutons de r√©ponse
  document.querySelectorAll('.game-futur button:not(#nextFutur)').forEach(btn => {
    btn.disabled = false;
  });
  
  // Si toutes les phrases ont √©t√© utilis√©es, r√©initialiser
  if (gameData.usedIndices.length >= gameData.data.length) {
    console.log('Toutes les phrases ont √©t√© utilis√©es, r√©initialisation...');
    gameData.usedIndices = [];
  }
  
  // Choisir une nouvelle phrase al√©atoire qui n'a pas encore √©t√© utilis√©e
  let newIndex;
  do {
    newIndex = Math.floor(Math.random() * gameData.data.length);
  } while (gameData.usedIndices.includes(newIndex) && gameData.usedIndices.length < gameData.data.length);
  
  console.log('Nouvel index choisi:', newIndex, 'sur', gameData.data.length - 1);
  
  // Mettre √† jour l'index actuel et l'ajouter aux indices utilis√©s
  gameData.current = newIndex;
  gameData.usedIndices.push(newIndex);
  
  console.log('Nouvelle phrase charg√©e:', gameData.data[gameData.current]);
  console.log('Index actuel apr√®s mise √† jour:', gameData.current);
  
  // Afficher la nouvelle phrase
  console.log('Appel de renderPhrase avec game:', game);
  renderPhrase(game);
  
  // D√©sactiver le bouton suivant jusqu'√† ce qu'une r√©ponse soit donn√©e
  if (game === 'futur') {
    const nextBtn = document.getElementById('nextFutur');
    if (nextBtn) nextBtn.disabled = true;
  } else {
    const nextBtn = document.getElementById('nextBtn');
    if (nextBtn) nextBtn.disabled = true;
  }
}

// Variables pour stocker la s√©lection de l'utilisateur
let selectedTemps = null;

// Fonction pour s√©lectionner un temps
function selectTemps(temps) {
  selectedTemps = temps;
  
  // Mettre √† jour le style des boutons
  document.querySelectorAll('.game-temps .button-group button').forEach(btn => {
    if (btn.textContent.includes(temps)) {
      btn.style.backgroundColor = '#4CAF50';
      btn.style.color = 'white';
    } else {
      btn.style.backgroundColor = '';
      btn.style.color = '';
    }
  });
  
  return document.getElementById('infinitif-input') && document.getElementById('infinitif-input').value.trim() !== '';
}

// Fonction pour s√©lectionner un temps et valider imm√©diatement
function selectAndCheckTemps(temps) {
  const isInfinitifValid = selectTemps(temps);
  
  if (!isInfinitifValid) {
    alert('Veuillez d\'abord entrer l\'infinitif du verbe');
    return;
  }
  
  checkTemps();
}

// Fonction pour v√©rifier la r√©ponse dans le jeu des temps
function checkTemps() {
  const game = 'temps';
  const infinitifInput = document.getElementById('infinitif-input');
  const userInfinitif = infinitifInput ? infinitifInput.value.trim().toLowerCase() : '';
  
  if (!selectedTemps) {
    alert('Veuillez s√©lectionner un temps');
    return;
  }
  
  if (!userInfinitif) {
    alert('Veuillez entrer l\'infinitif du verbe');
    return;
  }
  console.log('=== FONCTION checkTemps APPEL√âE ===');
  console.log('Temps choisi:', selectedTemps);
  
  if (!window.games) {
    console.error('L\'objet games n\'est pas encore charg√©');
    return;
  }
  
  // D√©sactiver les champs de saisie et les boutons
  if (infinitifInput) infinitifInput.disabled = true;
  document.querySelectorAll('.game-temps .button-group button').forEach(btn => {
    btn.disabled = true;
  });
  
  const gameData = window.games[game];
  if (!gameData) {
    console.error('Jeu non trouv√©:', game, 'Disponibles:', Object.keys(window.games));
    return;
  }
  
  const currentData = gameData.data[gameData.current];
  if (!currentData) {
    console.error('Aucune donn√©e pour la phrase actuelle');
    return;
  }
  
  const feedbackElement = document.getElementById('temps-feedback');
  const expectedAnswer = currentData.temps;
  const expectedInfinitif = currentData.infinitif.toLowerCase();
  
  console.log('R√©ponse attendue:', {
    temps: expectedAnswer,
    infinitif: expectedInfinitif
  }, 'R√©ponse donn√©e:', {
    temps: selectedTemps,
    infinitif: userInfinitif
  });
  
  const tempsCorrect = selectedTemps === expectedAnswer;
  const infinitifCorrect = userInfinitif === expectedInfinitif;
  
  if (tempsCorrect && infinitifCorrect) {
    console.log('Bonne r√©ponse pour le temps et l\'infinitif');
    feedbackElement.innerHTML = `‚úÖ Parfait ! ${expectedInfinitif} est bien au ${expectedAnswer}.<br>+1 point`;
    feedbackElement.style.color = 'green';
    gameData.totalPoints++;
  } else if (tempsCorrect && !infinitifCorrect) {
    console.log('Mauvaise r√©ponse pour l\'infinitif');
    feedbackElement.innerHTML = `‚ùå L'infinitif √©tait ${expectedInfinitif} (le temps √©tait correct).<br>-1 point`;
    feedbackElement.style.color = 'red';
    if (gameData.totalPoints > 0) gameData.totalPoints--;
    gameData.totalErreurs++;
  } else if (!tempsCorrect && infinitifCorrect) {
    console.log('Mauvaise r√©ponse pour le temps');
    feedbackElement.innerHTML = `‚ùå Le temps √©tait ${expectedAnswer} (l'infinitif √©tait correct).<br>-1 point`;
    feedbackElement.style.color = 'red';
    if (gameData.totalPoints > 0) gameData.totalPoints--;
    gameData.totalErreurs++;
  } else {
    console.log('Mauvaise r√©ponse pour le temps et l\'infinitif');
    feedbackElement.innerHTML = `‚ùå L'infinitif √©tait ${expectedInfinitif} et le temps √©tait ${expectedAnswer}.<br>-1 point`;
    feedbackElement.style.color = 'red';
    if (gameData.totalPoints > 0) gameData.totalPoints--;
    gameData.totalErreurs++;
    
    // Jouer un son d'erreur
    const errorSound = document.getElementById('error-sound');
    if (errorSound) {
      errorSound.play().catch(e => console.error('Erreur de lecture du son:', e));
    }
  }
  
  // Mettre √† jour le tableau des scores
  updateScoreboard(game);
  
  // D√©sactiver les boutons de r√©ponse et activer le bouton suivant
  document.querySelectorAll('.game-temps button:not(#nextTemps)').forEach(btn => {
    btn.disabled = true;
  });
  
  const nextBtn = document.getElementById('nextTemps');
  if (nextBtn) nextBtn.disabled = false;
}

// Fonction pour g√©rer le changement de jeu
function selectGame(game) {
  // Fermer le menu sur mobile/tablette
  if (window.innerWidth <= 1024) {
    const sidebar = document.querySelector('.sidebar');
    if (sidebar) {
      sidebar.classList.remove('active');
    }
  }

  // Mettre √† jour le menu
  document.querySelectorAll('.menu li').forEach(li => {
    li.classList.remove('active');
    if (li.children[0].href.includes(`#${game}`)) {
      li.classList.add('active');
    }
  });

  // Cacher tous les jeux
  document.querySelectorAll('.game-content > div').forEach(div => {
    div.style.display = 'none';
  });

  // Afficher le jeu s√©lectionn√©
  const gameDiv = document.querySelector(`.game-${game}`);
  if (gameDiv) {
    gameDiv.style.display = 'block';
    
    // Initialiser le jeu de conjugaison si c'est le jeu s√©lectionn√©
    if (game === 'conjugaison') {
      initConjugaison();
    }
  } else {
    console.error('√âl√©ment du jeu non trouv√©:', `.game-${game}`);
  }

  // R√©initialiser les scores
  resetGame(game);
}

// Fonction pour g√©rer le menu hamburger
function toggleMenu() {
  const sidebar = document.querySelector('.sidebar');
  const menuBtn = document.querySelector('.menu-btn');
  
  if (sidebar.style.left === '0px' || !sidebar.style.left) {
    sidebar.style.left = '-250px';
    menuBtn.textContent = '‚ò∞';
    menuBtn.style.left = '10px';
  } else {
    sidebar.style.left = '0';
    menuBtn.textContent = '‚úï';
    menuBtn.style.left = '260px';
  }
}

// Fonction utilitaire pour m√©langer un tableau
function melangerTableau(array) {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
}

// Alias pour la compatibilit√© avec le code existant
const shuffleArray = melangerTableau;

// Afficher le prochain verbe √† conjuguer
function nextVerbe() {
  if (!verbesData || verbesData.length === 0) {
    const element = document.getElementById('conjugaison-verbe');
    if (element) element.textContent = 'Tous les verbes ont √©t√© utilis√©s !';
    const checkBtn = document.getElementById('check-conjugaison');
    if (checkBtn) checkBtn.disabled = true;
    return;
  }
  
  // Prendre le premier verbe de la liste
  currentVerbe = verbesData.shift();
  const verbeElement = document.getElementById('verbe-infinitif');
  if (verbeElement) verbeElement.textContent = currentVerbe.infinitif;
  
  // R√©initialiser les champs
  document.querySelectorAll('.conjugaison-input').forEach(input => {
    input.value = '';
    input.disabled = false;
    input.classList.remove('correct', 'incorrect');
  });
  
  // R√©initialiser les r√©sultats
  document.querySelectorAll('.conjugaison-result').forEach(span => {
    span.textContent = '';
  });
  
  // R√©initialiser le feedback
  const feedback = document.getElementById('conjugaison-feedback');
  if (feedback) feedback.textContent = '';
  
  // D√©sactiver le bouton suivant
  const nextBtn = document.getElementById('next-conjugaison');
  if (nextBtn) nextBtn.disabled = true;
  
  // Activer le bouton de v√©rification
  const checkBtn = document.getElementById('check-conjugaison');
  if (checkBtn) checkBtn.disabled = false;
}

// V√©rifier les r√©ponses
function checkConjugaison() {
  if (!currentVerbe) return;
  
  let score = 0;
  const personnes = ['je', 'tu', 'il', 'nous', 'vous', 'ils'];
  
  personnes.forEach(personne => {
    const input = document.getElementById(`conj-${personne}`);
    const resultSpan = document.getElementById(`result-${personne}`);
    if (!input || !resultSpan) return;
    
    const reponse = input.value.trim().toLowerCase();
    const bonneReponse = currentVerbe.conjugaisons[personne];
    
    if (reponse === bonneReponse) {
      input.classList.add('correct');
      input.classList.remove('incorrect');
      resultSpan.textContent = '‚úì';
      resultSpan.className = 'conjugaison-result correct';
      score++;
    } else {
      input.classList.add('incorrect');
      input.classList.remove('correct');
      resultSpan.textContent = bonneReponse;
      resultSpan.className = 'conjugaison-result incorrect';
    }
    
    // D√©sactiver le champ apr√®s v√©rification
    input.disabled = true;
  });
  
  // Afficher le score
  const scoreText = `Score : ${score}/6`;
  const feedback = document.getElementById('conjugaison-feedback');
  if (feedback) {
    feedback.textContent = score === 6 
      ? `‚úÖ Parfait ! ${scoreText}` 
      : `‚ùå ${scoreText} - Essayez encore ou passez au verbe suivant`;
  }
  
  // Activer le bouton suivant
  const nextBtn = document.getElementById('next-conjugaison');
  if (nextBtn) nextBtn.disabled = false;
  
  // D√©sactiver le bouton de v√©rification
  const checkBtn = document.getElementById('check-conjugaison');
  if (checkBtn) checkBtn.disabled = true;
}

// Variables globales pour le jeu de conjugaison
let scoreConjugaison = 0;
let totalVerbes = 0;

// Variables globales pour le jeu de g√©om√©trie
let scoreGeometrie = 0;
let totalGeometrie = 0;
let formeActuelle = null;
let niveauActuel = null;
let formes = [];
let formesRestantes = [];
let geometrieData = {};

// Donn√©es pour le jeu de d√©finitions
const definitionsData = [
  {
    id: 'polygone',
    terme: 'Polygone',
    definition: 'Une surface dont tous les c√¥t√©s sont droits',
    image: 'images/geometrie/pentagone.svg',
    reponses: [
      'Une surface dont tous les c√¥t√©s sont droits',
      'Un polygone √† 4 c√¥t√©s',
      'Une figure avec des courbes'
    ]
  },
  {
    id: 'quadrilatere',
    terme: 'Quadrilat√®re',
    definition: 'Un polygone √† 4 c√¥t√©s',
    image: 'images/geometrie/rectangle.svg',
    reponses: [
      'Un polygone √† 4 c√¥t√©s',
      'Un polygone √† 3 c√¥t√©s',
      'Un polygone √† 5 c√¥t√©s'
    ]
  },
  {
    id: 'triangle',
    terme: 'Triangle',
    definition: 'Un polygone √† 3 c√¥t√©s',
    image: 'images/geometrie/triangle.svg',
    reponses: [
      'Un polygone √† 3 c√¥t√©s',
      'Un polygone √† 4 c√¥t√©s',
      'Un polygone √† 5 c√¥t√©s'
    ]
  },
  {
    id: 'pentagone',
    terme: 'Pentagone',
    definition: 'Un polygone √† 5 c√¥t√©s',
    image: 'images/geometrie/pentagone.svg',
    reponses: [
      'Un polygone √† 5 c√¥t√©s',
      'Un polygone √† 4 c√¥t√©s',
      'Un polygone √† 6 c√¥t√©s'
    ]
  },
  {
    id: 'hexagone',
    terme: 'Hexagone',
    definition: 'Un polygone √† 6 c√¥t√©s',
    image: 'images/geometrie/hexagone.svg',
    reponses: [
      'Un polygone √† 6 c√¥t√©s',
      'Un polygone √† 5 c√¥t√©s',
      'Un polygone √† 4 c√¥t√©s'
    ]
  },
  {
    id: 'octogone',
    terme: 'Octogone',
    definition: 'Un polygone √† 8 c√¥t√©s',
    image: 'images/geometrie/octogone.svg',
    reponses: [
      'Un polygone √† 8 c√¥t√©s',
      'Un polygone √† 6 c√¥t√©s',
      'Un polygone √† 10 c√¥t√©s'
    ]
  },
  {
    id: 'cercle',
    terme: 'Cercle',
    definition: 'Une figure plane dont tous les points sont √† √©gale distance d\'un point central appel√© centre',
    image: 'images/geometrie/cercle.svg',
    reponses: [
      'Une figure plane dont tous les points sont √† √©gale distance d\'un point central appel√© centre',
      'Un polygone √† 4 c√¥t√©s √©gaux',
      'Un polygone √† 3 c√¥t√©s'
    ]
  },
  {
    id: 'carre',
    terme: 'Carr√©',
    definition: 'Un quadrilat√®re qui a 4 c√¥t√©s isom√©triques et 4 angles droits',
    image: 'images/geometrie/carre.svg',
    reponses: [
      'Un quadrilat√®re qui a 4 c√¥t√©s isom√©triques et 4 angles droits',
      'Un quadrilat√®re avec 2 paires de c√¥t√©s parall√®les',
      'Un polygone √† 6 c√¥t√©s'
    ]
  },
  {
    id: 'rectangle',
    terme: 'Rectangle',
    definition: 'Un quadrilat√®re qui a 4 angles droits et des c√¥t√©s oppos√©s de m√™me longueur',
    image: 'images/geometrie/rectangle.svg',
    reponses: [
      'Un quadrilat√®re qui a 4 angles droits et des c√¥t√©s oppos√©s de m√™me longueur',
      'Un quadrilat√®re avec 4 c√¥t√©s √©gaux',
      'Un polygone √† 3 c√¥t√©s'
    ]
  },
  {
    id: 'losange',
    terme: 'Losange',
    definition: 'Un quadrilat√®re qui a 4 c√¥t√©s de m√™me longueur et des c√¥t√©s oppos√©s parall√®les',
    image: 'images/geometrie/losange.svg',
    reponses: [
      'Un quadrilat√®re qui a 4 c√¥t√©s de m√™me longueur et des c√¥t√©s oppos√©s parall√®les',
      'Un quadrilat√®re avec 4 angles droits',
      'Un polygone √† 5 c√¥t√©s'
    ]
  },
  {
    id: 'parallelogramme',
    terme: 'Parall√©logramme',
    definition: 'Un quadrilat√®re dont les c√¥t√©s oppos√©s sont parall√®les et de m√™me longueur',
    image: 'images/geometrie/parallelogramme.svg',
    reponses: [
      'Un quadrilat√®re dont les c√¥t√©s oppos√©s sont parall√®les et de m√™me longueur',
      'Un quadrilat√®re avec 4 angles droits',
      'Un polygone √† 5 c√¥t√©s √©gaux'
    ]
  },
  {
    id: 'trapeze',
    terme: 'Trap√®ze',
    definition: 'Un quadrilat√®re qui a au moins une paire de c√¥t√©s parall√®les',
    image: 'images/geometrie/trapeze.svg',
    reponses: [
      'Un quadrilat√®re qui a au moins une paire de c√¥t√©s parall√®les',
      'Un quadrilat√®re avec 4 c√¥t√©s √©gaux',
      'Un polygone √† 3 c√¥t√©s'
    ]
  },
  {
    id: 'triangle-equilateral',
    terme: 'Triangle √©quilat√©ral',
    definition: 'Un triangle qui a ses trois c√¥t√©s de m√™me longueur',
    image: 'images/geometrie/triangle-equilateral.svg',
    reponses: [
      'Un triangle qui a ses trois c√¥t√©s de m√™me longueur',
      'Un triangle avec deux c√¥t√©s √©gaux',
      'Un triangle avec un angle droit'
    ]
  },
  {
    id: 'triangle-isocele',
    terme: 'Triangle isoc√®le',
    definition: 'Un triangle qui a deux c√¥t√©s de m√™me longueur',
    image: 'images/geometrie/triangle-isocele.svg',
    reponses: [
      'Un triangle qui a deux c√¥t√©s de m√™me longueur',
      'Un triangle avec trois c√¥t√©s √©gaux',
      'Un triangle avec un angle obtus'
    ]
  },
  {
    id: 'triangle-rectangle',
    terme: 'Triangle rectangle',
    definition: 'Un triangle qui a un angle droit',
    image: 'images/geometrie/triangle-rectangle.svg',
    reponses: [
      'Un triangle qui a un angle droit',
      'Un triangle avec trois c√¥t√©s √©gaux',
      'Un triangle avec un angle obtus'
    ]
  },
  {
    id: 'triangle-quelconque',
    terme: 'Triangle quelconque',
    definition: 'Un triangle qui n\'a pas de propri√©t√©s particuli√®res',
    image: 'images/geometrie/triangle-quelconque.svg',
    reponses: [
      'Un triangle qui n\'a pas de propri√©t√©s particuli√®res',
      'Un triangle avec trois c√¥t√©s √©gaux',
      'Un triangle avec un angle droit'
    ]
  },
  {
    id: 'disque',
    terme: 'Disque',
    definition: 'La surface d√©limit√©e par un cercle',
    image: 'images/geometrie/disque.svg',
    reponses: [
      'La surface d√©limit√©e par un cercle',
      'La ligne qui forme un cercle',
      'Un demi-cercle'
    ]
  },
  {
    id: 'ovale',
    terme: 'Ovale',
    definition: 'Une forme arrondie allong√©e qui ressemble √† un ≈ìuf',
    image: 'images/geometrie/ovale.svg',
    reponses: [
      'Une forme arrondie allong√©e qui ressemble √† un ≈ìuf',
      'Un cercle parfait',
      'Un demi-cercle'
    ]
  },
  {
    id: 'demi-cercle',
    terme: 'Demi-cercle',
    definition: 'La moiti√© d\'un cercle, d√©limit√©e par un diam√®tre et un demi-p√©rim√®tre',
    image: 'images/geometrie/demi-cercle.svg',
    reponses: [
      'La moiti√© d\'un cercle, d√©limit√©e par un diam√®tre et un demi-p√©rim√®tre',
      'Un cercle complet',
      'Un quart de cercle'
    ]
  },
  {
    id: 'secteur-circulaire',
    terme: 'Secteur circulaire',
    definition: 'Une portion de disque d√©limit√©e par deux rayons et un arc de cercle',
    image: 'images/geometrie/secteur-circulaire.svg',
    reponses: [
      'Une portion de disque d√©limit√©e par deux rayons et un arc de cercle',
      'La moiti√© d\'un cercle',
      'Un quart de cercle'
    ]
  },
  {
    id: 'segment-circulaire',
    terme: 'Segment circulaire',
    definition: 'La portion de disque comprise entre un arc de cercle et la corde qui le sous-tend',
    image: 'images/geometrie/segment-circulaire.svg',
    reponses: [
      'La portion de disque comprise entre un arc de cercle et la corde qui le sous-tend',
      'La moiti√© d\'un cercle',
      'Un secteur angulaire'
    ]
  },
  {
    id: 'couronne-circulaire',
    terme: 'Couronne circulaire',
    definition: 'La surface comprise entre deux cercles concentriques',
    image: 'images/geometrie/couronne-circulaire.svg',
    reponses: [
      'La surface comprise entre deux cercles concentriques',
      'Un demi-cercle',
      'Un secteur angulaire'
    ]
  },
  {
    id: 'ellipse',
    terme: 'Ellipse',
    definition: 'Une courbe plane ferm√©e qui ressemble √† un cercle allong√©',
    image: 'images/geometrie/ellipse.svg',
    reponses: [
      'Une courbe plane ferm√©e qui ressemble √† un cercle allong√©',
      'Un cercle parfait',
      'Une parabole'
    ]
  },
  {
    id: 'parabole',
    terme: 'Parabole',
    definition: 'Une courbe plane sym√©trique dont chaque point est √† √©gale distance d\'un point fixe (foyer) et d\'une droite fixe (directrice)',
    image: 'images/geometrie/parabole.svg',
    reponses: [
      'Une courbe plane sym√©trique dont chaque point est √† √©gale distance d\'un point fixe et d\'une droite fixe',
      'Un cercle',
      'Une ellipse'
    ]
  },
  {
    id: 'hyperbole',
    terme: 'Hyperbole',
    definition: 'Une courbe plane ouverte √† deux branches, obtenue par l\'intersection d\'un c√¥ne avec un plan parall√®le √† son axe',
    image: 'images/geometrie/hyperbole.svg',
    reponses: [
      'Une courbe plane ouverte √† deux branches, obtenue par l\'intersection d\'un c√¥ne avec un plan parall√®le √† son axe',
      'Une parabole',
      'Une ellipse'
    ]
  },
  {
    id: 'spirale',
    terme: 'Spirale',
    definition: 'Une courbe plane qui tourne autour d\'un point central en s\'en √©loignant de plus en plus',
    image: 'images/geometrie/spirale.svg',
    reponses: [
      'Une courbe plane qui tourne autour d\'un point central en s\'en √©loignant de plus en plus',
      'Un cercle',
      'Une parabole'
    ]
  },
  {
    id: 'parallelogramme',
    terme: 'Parall√©logramme',
    definition: 'Un quadrilat√®re qui a 2 paires de c√¥t√©s parall√®les',
    image: 'images/geometrie/parallelogramme.svg',
    reponses: [
      'Un quadrilat√®re qui a 1 paire de c√¥t√©s parall√®les',
      'Un quadrilat√®re qui a 2 paires de c√¥t√©s parall√®les',
      'Un quadrilat√®re avec 4 angles droits'
    ]
  },
  {
    id: 'trapeze',
    terme: 'Trap√®ze',
    definition: 'Un quadrilat√®re qui a 1 paire de c√¥t√©s parall√®les',
    image: 'images/geometrie/trapeze.svg',
    reponses: [
      'Un quadrilat√®re avec 4 c√¥t√©s √©gaux',
      'Un quadrilat√®re qui a 1 paire de c√¥t√©s parall√®les',
      'Un polygone √† 3 c√¥t√©s'
    ]
  },
  {
    id: 'rectangle',
    terme: 'Rectangle',
    definition: 'Un quadrilat√®re qui a 4 angles droits',
    image: 'images/geometrie/rectangle.svg',
    reponses: [
      'Un quadrilat√®re avec 4 c√¥t√©s √©gaux',
      'Un quadrilat√®re qui a 4 angles droits',
      'Un polygone √† 5 c√¥t√©s'
    ]
  },
  {
    id: 'carre',
    terme: 'Carr√©',
    definition: 'Un quadrilat√®re avec quatre c√¥t√©s √©gaux et quatre angles droits',
    image: 'images/geometrie/carre.svg',
    reponses: [
      'Un quadrilat√®re avec 4 c√¥t√©s √©gaux et 4 angles droits',
      'Un quadrilat√®re avec 2 paires de c√¥t√©s √©gaux',
      'Un polygone √† 5 c√¥t√©s √©gaux'
    ]
  },
  {
    id: 'triangle',
    terme: 'Triangle',
    definition: 'Un polygone √† trois c√¥t√©s et trois angles',
    image: 'images/geometrie/triangle.svg',
    reponses: [
      'Un polygone √† trois c√¥t√©s',
      'Un polygone √† quatre c√¥t√©s',
      'Un polygone √† cinq c√¥t√©s'
    ]
  },
  {
    id: 'cercle',
    terme: 'Cercle',
    definition: 'Une figure plane dont tous les points sont √† √©gale distance d\'un point central',
    image: 'images/geometrie/cercle.svg',
    reponses: [
      'Figure dont tous les points sont √† √©gale distance du centre',
      'Figure √† quatre c√¥t√©s √©gaux',
      'Figure √† trois c√¥t√©s',
      'Figure √† cinq c√¥t√©s'
    ]
  },
  {
    id: 'rectangle',
    terme: 'rectangle',
    definition: 'Un quadrilat√®re avec quatre angles droits et des c√¥t√©s oppos√©s de m√™me longueur.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Rectangle_Geometry_Vector.svg/1200px-Rectangle_Geometry_Vector.svg.png',
    reponses: [
      'Quadrilat√®re avec quatre angles droits et c√¥t√©s oppos√©s √©gaux',
      'Figure √† trois c√¥t√©s',
      'Figure ronde',
      'Figure √† six c√¥t√©s √©gaux'
    ]
  },
  {
    terme: 'losange',
    definition: 'Un quadrilat√®re dont les quatre c√¥t√©s sont de m√™me longueur et dont les c√¥t√©s oppos√©s sont parall√®les.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Rhombus_1.svg/1200px-Rhombus_1.svg.png',
    reponses: [
      'Quadrilat√®re avec quatre c√¥t√©s √©gaux et c√¥t√©s oppos√©s parall√®les',
      'Figure √† trois c√¥t√©s √©gaux',
      'Figure √† quatre angles droits',
      'Figure √† cinq c√¥t√©s'
    ]
  },
  {
    terme: 'parall√©logramme',
    definition: 'Un quadrilat√®re dont les c√¥t√©s oppos√©s sont parall√®les et de m√™me longueur.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Parallelogram_geometry.png/1200px-Parallelogram_geometry.png',
    reponses: [
      'Quadrilat√®re avec c√¥t√©s oppos√©s parall√®les et de m√™me longueur',
      'Figure √† trois c√¥t√©s',
      'Figure ronde',
      'Figure √† six c√¥t√©s √©gaux'
    ]
  },
  {
    terme: 'trap√®ze',
    definition: 'Un quadrilat√®re qui a au moins une paire de c√¥t√©s parall√®les.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Trapezoid_%28trapezium%29.svg/1200px-Trapezoid_%28trapezium%29.svg.png',
    reponses: [
      'Quadrilat√®re avec au moins une paire de c√¥t√©s parall√®les',
      'Figure √† trois c√¥t√©s',
      'Figure √† quatre c√¥t√©s √©gaux',
      'Figure ronde'
    ]
  },
  {
    terme: 'pentagone',
    definition: 'Un polygone √† cinq c√¥t√©s et cinq angles.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Pentagon.svg/1200px-Pentagon.svg.png',
    reponses: [
      'Polygone √† cinq c√¥t√©s et cinq angles',
      'Figure √† trois c√¥t√©s',
      'Figure √† quatre c√¥t√©s √©gaux',
      'Figure ronde'
    ]
  },
  {
    terme: 'hexagone',
    definition: 'Un polygone √† six c√¥t√©s et six angles.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Regular_hexagon.svg/1200px-Regular_hexagon.svg.png',
    reponses: [
      'Polygone √† six c√¥t√©s et six angles',
      'Figure √† cinq c√¥t√©s',
      'Figure √† quatre c√¥t√©s √©gaux',
      'Figure √† trois c√¥t√©s'
    ]
  },
  {
    terme: 'octogone',
    definition: 'Un polygone √† huit c√¥t√©s et huit angles.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Regular_octagon.svg/1200px-Regular_octagon.svg.png',
    reponses: [
      'Polygone √† huit c√¥t√©s et huit angles',
      'Figure √† six c√¥t√©s',
      'Figure √† cinq c√¥t√©s',
      'Figure √† quatre c√¥t√©s √©gaux'
    ]
  }
];

// Variables d'√©tat pour le jeu de d√©finitions
let definitionsRestantes = [];
let definitionActuelle = null;
let reponsesMelangees = [];
let reponseCorrecte = '';
let reponseSelectionnee = '';
let scoreDefinitions = 0;
let totalDefinitions = 0;

// Initialiser le jeu de d√©finitions
function initialiserJeuDefinitions() {
  // Copier toutes les d√©finitions
  definitionsRestantes = [...definitionsData];
  scoreDefinitions = 0;
  totalDefinitions = definitionsData.length;
  
  // M√©langer les d√©finitions
  definitionsRestantes = melangerTableau(definitionsRestantes);
  
  // Afficher la premi√®re d√©finition
  afficherDefinitionSuivante();
  
  // Mettre √† jour le score
  document.getElementById('score-definitions').textContent = scoreDefinitions;
  document.getElementById('total-definitions').textContent = totalDefinitions;
}

// Afficher une d√©finition al√©atoire
function afficherDefinitionSuivante() {
  const definitionsList = document.getElementById('definitions-list');
  const shapesContainer = document.getElementById('shapes-container');
  const feedbackDef = document.getElementById('feedback-def');
  
  // R√©initialiser la r√©ponse s√©lectionn√©e
  reponseSelectionnee = '';
  
  // R√©initialiser l'interface
  definitionsList.innerHTML = '';
  shapesContainer.innerHTML = '';
  feedbackDef.textContent = '';
  feedbackDef.className = 'feedback-def';
  document.getElementById('verifier-def').style.display = 'inline-block';
  document.getElementById('suivant-def').style.display = 'none';
  
  // V√©rifier s'il reste des d√©finitions
  if (definitionsRestantes.length === 0) {
    // Toutes les d√©finitions ont √©t√© vues
    definitionsList.innerHTML = '<div class="feedback correct">F√©licitations ! Vous avez termin√© toutes les d√©finitions. Score final : ' + scoreDefinitions + ' / ' + totalDefinitions + '</div>';
    document.getElementById('verifier-def').style.display = 'none';
    document.getElementById('suivant-def').style.display = 'none';
    return;
  }
  
  // Prendre la premi√®re d√©finition de la liste
  definitionActuelle = definitionsRestantes.shift();
  
  // M√©langer les r√©ponses
  reponsesMelangees = melangerTableau([...definitionActuelle.reponses]);
  reponseCorrecte = definitionActuelle.definition;
  
  // Afficher le terme √† d√©finir
  const termeElement = document.createElement('h3');
  termeElement.textContent = `Quelle est la d√©finition d'un ${definitionActuelle.terme} ?`;
  definitionsList.appendChild(termeElement);
  
  // Afficher les r√©ponses possibles
  reponsesMelangees.forEach((reponse, index) => {
    const reponseElement = document.createElement('div');
    reponseElement.className = 'definition-item';
    reponseElement.textContent = reponse;
    reponseElement.setAttribute('data-reponse', reponse);
    reponseElement.setAttribute('draggable', 'true');
    
    // Gestion du glisser-d√©poser
    reponseElement.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/plain', reponse);
      reponseElement.classList.add('dragging');
    });
    
    reponseElement.addEventListener('dragend', () => {
      reponseElement.classList.remove('dragging');
    });
    
    // Gestion du clic
    reponseElement.addEventListener('click', () => {
      document.querySelectorAll('.definition-item').forEach(item => {
        item.classList.remove('selected');
      });
      reponseElement.classList.add('selected');
      reponseSelectionnee = reponse;
    });
    
    definitionsList.appendChild(reponseElement);
  });
  
  // Configurer la zone de d√©p√¥t
  const shapeTarget = document.createElement('div');
  shapeTarget.className = 'shape-target';
  shapeTarget.innerHTML = `
    <img src="${definitionActuelle.image}" alt="${definitionActuelle.terme}">
    <p>D√©posez la d√©finition ici</p>
  `;
  
  // Gestion des √©v√©nements de glisser-d√©poser
  shapeTarget.addEventListener('dragover', (e) => {
    e.preventDefault();
    shapeTarget.classList.add('highlight');
  });
  
  shapeTarget.addEventListener('dragleave', () => {
    shapeTarget.classList.remove('highlight');
  });
  
  shapeTarget.addEventListener('drop', (e) => {
    e.preventDefault();
    shapeTarget.classList.remove('highlight');
    
    const reponse = e.dataTransfer.getData('text/plain');
    reponseSelectionnee = reponse;
    
    // Mettre en surbrillance la r√©ponse s√©lectionn√©e
    document.querySelectorAll('.definition-item').forEach(item => {
      item.classList.remove('selected');
      if (item.textContent === reponse) {
        item.classList.add('selected');
      }
    });
    
    // Afficher la r√©ponse dans la zone de d√©p√¥t
    shapeTarget.innerHTML = `
      <img src="${definitionActuelle.image}" alt="${definitionActuelle.terme}">
      <p>${reponse}</p>
    `;
  });
  
  shapesContainer.appendChild(shapeTarget);
}

// V√©rifier la r√©ponse s√©lectionn√©e
function verifierReponseDefinition() {
  const feedbackDef = document.getElementById('feedback-def');
  const shapeTarget = document.querySelector('.shape-target');
  const verifierBtn = document.getElementById('verifier-def');
  const suivantBtn = document.getElementById('suivant-def');
  
  if (!reponseSelectionnee) {
    feedbackDef.textContent = 'Veuillez s√©lectionner une r√©ponse.';
    feedbackDef.className = 'feedback-def incorrect';
    feedbackDef.style.display = 'block';
    return;
  }
  
  const estCorrect = reponseSelectionnee === reponseCorrecte;
  
  if (estCorrect) {
    scoreDefinitions++;
    feedbackDef.textContent = 'Correct ! ' + definitionActuelle.definition;
    feedbackDef.className = 'feedback-def correct';
    shapeTarget.classList.add('correct');
  } else {
    feedbackDef.innerHTML = `Incorrect. La bonne r√©ponse √©tait : <strong>${reponseCorrecte}</strong>`;
    feedbackDef.className = 'feedback-def incorrect';
    shapeTarget.classList.add('incorrect');
  }
  
  // Mettre √† jour le score
  document.getElementById('score-definitions').textContent = scoreDefinitions;
  
  // Changer les boutons
  verifierBtn.style.display = 'none';
  suivantBtn.style.display = 'inline-block';
  
  // D√©sactiver le glisser-d√©poser
  document.querySelectorAll('.definition-item').forEach(item => {
    item.setAttribute('draggable', 'false');
  });
}

// Charger les donn√©es de g√©om√©trie
function chargerDonneesGeometrie() {
  return fetch('geometrie.json')
    .then(response => response.json())
    .then(data => {
      geometrieData = data;
      return data;
    })
    .catch(error => {
      console.error('Erreur lors du chargement des donn√©es de g√©om√©trie :', error);
      throw error;
    });
}

// Afficher le verbe actuel √† conjuguer
function afficherVerbeActuel() {
  if (!verbesData || verbesData.length === 0) {
    console.error('Aucun verbe disponible');
    return;
  }
  
  const verbe = verbesData[currentVerbeIndex];
  if (!verbe || !verbe.infinitif) {
    console.error('Donn√©es de verbe invalides:', verbe);
    return;
  }
  
  // Mettre √† jour l'infinitif du verbe
  const verbeInfinitifElement = document.getElementById('verbe-infinitif');
  if (verbeInfinitifElement) {
    verbeInfinitifElement.textContent = verbe.infinitif;
  }
  
  // R√©initialiser les champs de saisie et les retours visuels
  const personnes = ['je', 'tu', 'il', 'nous', 'vous', 'ils'];
  personnes.forEach(personne => {
    const inputElement = document.getElementById(`conj-${personne}`);
    const resultElement = document.getElementById(`result-${personne}`);
    
    if (inputElement) {
      inputElement.value = '';
      inputElement.disabled = false;
    }
    
    if (resultElement) {
      resultElement.textContent = '';
      resultElement.className = 'conjugaison-result';
    }
  });
  
  // D√©sactiver le bouton suivant
  const nextButton = document.getElementById('next-conjugaison');
  if (nextButton) {
    nextButton.disabled = true;
  }
  
  // R√©initialiser le feedback
  const feedbackElement = document.getElementById('conjugaison-feedback');
  if (feedbackElement) {
    feedbackElement.textContent = '';
    feedbackElement.className = 'conjugaison-feedback';
  }
  
  // Mettre √† jour le compteur
  const compteurElement = document.getElementById('verbe-compteur');
  if (compteurElement) {
    compteurElement.textContent = `${currentVerbeIndex + 1} / ${totalVerbes}`;
  }
}

// Initialiser le jeu de conjugaison
function initConjugaison() {
  console.log('Initialisation du jeu de conjugaison...');
  
  // R√©initialiser les variables du jeu
  scoreConjugaison = 0;
  totalVerbes = 0;
  currentVerbeIndex = 0;
  verbesData = [];
  
  // Mettre √† jour l'interface utilisateur
  const scoreElement = document.getElementById('score-conjugaison');
  const totalElement = document.getElementById('total-verbes');
  const feedbackElement = document.getElementById('conjugaison-feedback');
  
  if (scoreElement) scoreElement.textContent = '0';
  if (totalElement) totalElement.textContent = '0';
  if (feedbackElement) {
    feedbackElement.textContent = 'Chargement des verbes...';
    feedbackElement.className = 'conjugaison-feedback';
  }
  
  // Charger les donn√©es des verbes
  fetch('futur-conjugaison.json')
    .then(response => {
      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      console.log('Donn√©es des verbes charg√©es avec succ√®s:', data);
      
      if (!data || !data.verbes || !Array.isArray(data.verbes)) {
        throw new Error('Format de donn√©es invalide dans futur-conjugaison.json');
      }
      
      verbesData = data.verbes;
      totalVerbes = verbesData.length;
      currentVerbeIndex = 0;
      
      console.log(`Chargement de ${totalVerbes} verbes`);
      
      // Mettre √† jour l'interface utilisateur
      if (totalElement) totalElement.textContent = totalVerbes;
      if (feedbackElement) feedbackElement.textContent = '';
      
      // Afficher le premier verbe
      afficherVerbeActuel();
      
      // Ajouter les √©couteurs d'√©v√©nements s'ils n'existent pas d√©j√†
      const checkButton = document.getElementById('check-conjugaison');
      const nextButton = document.getElementById('next-conjugaison');
      
      if (checkButton) {
        checkButton.onclick = verifierConjugaison;
      }
      
      if (nextButton) {
        nextButton.onclick = () => {
          currentVerbeIndex = (currentVerbeIndex + 1) % verbesData.length;
          afficherVerbeActuel();
        };
      }
      
      console.log('Jeu de conjugaison initialis√© avec succ√®s');
    })
    .catch(error => {
      console.error('Erreur lors du chargement des verbes :', error);
      const errorMessage = `Erreur lors du chargement des verbes : ${error.message}`;
      
      if (feedbackElement) {
        feedbackElement.textContent = errorMessage;
        feedbackElement.className = 'conjugaison-feedback error';
      }
      
      // Afficher un message d'erreur plus visible
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error-message';
      errorDiv.style.color = 'red';
      errorDiv.style.padding = '10px';
      errorDiv.style.margin = '10px 0';
      errorDiv.style.border = '1px solid red';
      errorDiv.style.borderRadius = '5px';
      errorDiv.textContent = errorMessage;
      
      const gameContainer = document.querySelector('.game-conjugaison');
      if (gameContainer) {
        gameContainer.insertBefore(errorDiv, gameContainer.firstChild);
      }
    });
}

// V√©rifier les r√©ponses de conjugaison
function verifierConjugaison() {
  if (!verbesData || currentVerbeIndex >= verbesData.length) {
    console.error('Aucune donn√©e de verbe disponible ou index invalide');
    return;
  }
  
  const verbe = verbesData[currentVerbeIndex];
  if (!verbe || !verbe.conjugaisons) {
    console.error('Donn√©es de verbe invalides:', verbe);
    return;
  }
  
  let toutesCorrectes = true;
  const personnes = ['je', 'tu', 'il', 'nous', 'vous', 'ils'];
  
  // V√©rifier chaque personne
  personnes.forEach(personne => {
    const inputElement = document.getElementById(`conj-${personne}`);
    const resultElement = document.getElementById(`result-${personne}`);
    
    if (!inputElement || !resultElement) {
      console.error(`√âl√©ment non trouv√© pour la personne: ${personne}`);
      return;
    }
    
    const reponse = inputElement.value.trim().toLowerCase();
    const reponseCorrecte = verbe.conjugaisons[personne];
    
    if (!reponseCorrecte) {
      console.error(`Aucune conjugaison trouv√©e pour la personne: ${personne}`, verbe);
      return;
    }
    
    if (reponse === reponseCorrecte.toLowerCase()) {
      resultElement.textContent = '‚úì';
      resultElement.className = 'conjugaison-result correct';
    } else {
      resultElement.textContent = reponseCorrecte;
      resultElement.className = 'conjugaison-result incorrect';
      toutesCorrectes = false;
    }
  });
  
  // Mettre √† jour le feedback
  const feedbackElement = document.getElementById('conjugaison-feedback');
  if (toutesCorrectes) {
    scoreConjugaison++;
    document.getElementById('score-conjugaison').textContent = scoreConjugaison;
    feedbackElement.textContent = 'Bravo ! Toutes les r√©ponses sont correctes !';
    feedbackElement.className = 'conjugaison-feedback success';
  } else {
    feedbackElement.textContent = 'Certaines r√©ponses sont incorrectes. Corrigez-les et r√©essayez.';
    feedbackElement.className = 'conjugaison-feedback error';
  }
  
  // Activer le bouton suivant
  document.getElementById('next-conjugaison').disabled = false;
}

// Fonction pour charger les donn√©es de g√©om√©trie
function chargerDonneesGeometrie() {
  console.log('D√©but du chargement des donn√©es de g√©om√©trie...');
  
  // Retourner une promesse pour permettre le cha√Ænage
  return new Promise((resolve, reject) => {
    // V√©rifier si l'URL du fichier est valide
    const url = 'geometrie.json';
    if (!url) {
      const error = new Error('URL du fichier de donn√©es non d√©finie');
      console.error(error);
      reject(error);
      return;
    }
    
    console.log(`Chargement des donn√©es depuis: ${url}`);
    
    // Effectuer la requ√™te fetch
    fetch(url)
      .then(response => {
        console.log('R√©ponse re√ßue du serveur:', response.status, response.statusText);
        
        // V√©rifier si la r√©ponse est valide
        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status} ${response.statusText}`);
        }
        
        // Parser la r√©ponse en JSON
        return response.json()
          .then(data => {
            console.log('Donn√©es JSON pars√©es avec succ√®s');
            
            // V√©rifier que les donn√©es ont la structure attendue
            if (!data || typeof data !== 'object') {
              throw new Error('Les donn√©es re√ßues ne sont pas un objet JSON valide');
            }
            
            // V√©rifier la pr√©sence des niveaux
            if (!data.niveaux || !Array.isArray(data.niveaux)) {
              console.warn('Aucun tableau "niveaux" trouv√© dans les donn√©es, cr√©ation d\'un tableau vide');
              data.niveaux = [];
            }
            
            // Ajouter des valeurs par d√©faut si n√©cessaire
            data.definitions = data.definitions || {};
            
            // Stocker les donn√©es dans une variable globale
            window.geometrieData = data;
            
            console.log(`Donn√©es de g√©om√©trie charg√©es avec succ√®s: ${data.niveaux.length} niveaux disponibles`);
            
            // R√©soudre la promesse avec les donn√©es
            resolve(data);
          })
          .catch(parseError => {
            console.error('Erreur lors de l\'analyse du JSON:', parseError);
            throw new Error(`Format de donn√©es invalide: ${parseError.message}`);
          });
      })
      .catch(error => {
        console.error('Erreur lors du chargement des donn√©es de g√©om√©trie:', error);
        
        // Cr√©er un jeu de donn√©es par d√©faut en cas d'√©chec
        const defaultData = {
          niveaux: [
            {
              id: 'polygone-ou-non',
              nom: 'Polygone ou non ?',
              description: 'Identifiez si la forme est un polygone ou non.',
              formes: [
                { type: 'triangle', estPolygone: true, image: 'triangle.svg' },
                { type: 'cercle', estPolygone: false, image: 'cercle.svg' },
                { type: 'carre', estPolygone: true, image: 'carre.svg' },
                { type: 'rectangle', estPolygone: true, image: 'rectangle.svg' },
                { type: 'ovale', estPolygone: false, image: 'ovale.svg' }
              ]
            },
            {
              id: 'type-polygone',
              nom: 'Type de polygone',
              description: 'Identifiez si le polygone est un triangle ou un quadrilat√®re.',
              formes: [
                { type: 'triangle', cotes: 3, image: 'triangle.svg' },
                { type: 'rectangle', cotes: 4, image: 'rectangle.svg' },
                { type: 'carre', cotes: 4, image: 'carre.svg' },
                { type: 'triangle-isocele', cotes: 3, image: 'triangle-isocele.svg' }
              ]
            },
            {
              id: 'quadrilateres',
              nom: 'Les quadrilat√®res',
              description: 'Identifiez le type de quadrilat√®re.',
              formes: [
                { type: 'carre', cotes: 4, angles: 90, cotesEgaux: true, image: 'carre.svg' },
                { type: 'rectangle', cotes: 4, angles: 90, cotesEgaux: false, image: 'rectangle.svg' },
                { type: 'losange', cotes: 4, angles: 'non-90', cotesEgaux: true, image: 'losange.svg' },
                { type: 'parallelogramme', cotes: 4, angles: 'non-90', cotesEgaux: false, image: 'parallelogramme.svg' },
                { type: 'trapeze', cotes: 4, cotesParalleles: 1, image: 'trapeze.svg' }
              ]
            }
          ],
          definitions: {
            triangle: 'Un polygone √† trois c√¥t√©s et trois angles.',
            carre: 'Un quadrilat√®re avec quatre c√¥t√©s de m√™me longueur et quatre angles droits.',
            rectangle: 'Un quadrilat√®re avec quatre angles droits et des c√¥t√©s oppos√©s de m√™me longueur.',
            losange: 'Un quadrilat√®re avec quatre c√¥t√©s de m√™me longueur.',
            parallelogramme: 'Un quadrilat√®re dont les c√¥t√©s oppos√©s sont parall√®les et de m√™me longueur.',
            trapeze: 'Un quadrilat√®re avec au moins une paire de c√¥t√©s parall√®les.'
          }
        };
        
        console.warn('Utilisation des donn√©es par d√©faut en raison d\'une erreur de chargement');
        
        // Stocker les donn√©es par d√©faut
        window.geometrieData = defaultData;
        
        // R√©soudre la promesse avec les donn√©es par d√©faut
        resolve(defaultData);
      });
  });
}

// Initialisation du jeu de d√©finitions de g√©om√©trie
function initialiserJeuDefinitions() {
  console.log('Initialisation du jeu de d√©finitions');
  
  // V√©rifier que les donn√©es sont disponibles
  if (!window.definitionsData || !Array.isArray(window.definitionsData) || window.definitionsData.length === 0) {
    console.error('Aucune donn√©e de d√©finition disponible');
    document.getElementById('feedback-def').textContent = 'Erreur : Aucune donn√©e de d√©finition disponible';
    return;
  }
  
  // Initialiser les variables du jeu
  window.definitionsRestantes = [...window.definitionsData];
  window.definitionActuelle = null;
  window.reponsesMelangees = [];
  window.reponseCorrecte = '';
  window.reponseSelectionnee = null;
  window.scoreDefinitions = 0;
  window.totalDefinitions = window.definitionsData.length;
  
  // M√©langer les d√©finitions
  window.definitionsRestantes = melangerTableau(window.definitionsRestantes);
  
  // Afficher la premi√®re d√©finition
  afficherDefinitionSuivante();
  
  // Mettre √† jour le score
  document.getElementById('score-definitions').textContent = window.scoreDefinitions;
  document.getElementById('total-definitions').textContent = window.totalDefinitions;
  
  // Ajouter les √©couteurs d'√©v√©nements
  document.getElementById('verifier-def').addEventListener('click', verifierReponseDefinition);
  document.getElementById('suivant-def').addEventListener('click', afficherDefinitionSuivante);
  
  console.log('Jeu de d√©finitions initialis√© avec', window.definitionsRestantes.length, 'd√©finitions');
}

// Afficher la d√©finition suivante
function afficherDefinitionSuivante() {
  console.log('Affichage de la d√©finition suivante');
  
  // R√©initialiser l'interface
  document.getElementById('definitions-list').innerHTML = '';
  document.getElementById('shapes-container').innerHTML = '';
  document.getElementById('feedback-def').textContent = '';
  document.getElementById('verifier-def').style.display = 'inline-block';
  document.getElementById('suivant-def').style.display = 'none';
  
  // V√©rifier s'il reste des d√©finitions
  if (window.definitionsRestantes.length === 0) {
    // Toutes les d√©finitions ont √©t√© affich√©es
    document.getElementById('definitions-list').innerHTML = '<p>F√©licitations ! Vous avez termin√© toutes les d√©finitions.</p>';
    document.getElementById('verifier-def').style.display = 'none';
    document.getElementById('suivant-def').style.display = 'none';
    return;
  }
  
  // Prendre la prochaine d√©finition
  window.definitionActuelle = window.definitionsRestantes.pop();
  
  // Afficher la d√©finition
  const definitionElement = document.createElement('div');
  definitionElement.className = 'definition-item';
  definitionElement.textContent = window.definitionActuelle.definition;
  document.getElementById('definitions-list').appendChild(definitionElement);
  
  // M√©langer les r√©ponses
  window.reponsesMelangees = melangerTableau([...window.definitionActuelle.termes]);
  window.reponseCorrecte = window.definitionActuelle.termeCorrect;
  
  // Afficher les formes (r√©ponses possibles)
  window.reponsesMelangees.forEach((terme, index) => {
    const shapeElement = document.createElement('div');
    shapeElement.className = 'shape-item';
    shapeElement.dataset.terme = terme;
    shapeElement.innerHTML = `
      <img src="images/geometrie/${terme}.svg" alt="${terme}" class="shape-image">
      <div class="shape-name">${terme}</div>
    `;
    
    // Ajouter un √©couteur d'√©v√©nements pour la s√©lection
    shapeElement.addEventListener('click', () => {
      document.querySelectorAll('.shape-item').forEach(item => {
        item.classList.remove('selected');
      });
      shapeElement.classList.add('selected');
      window.reponseSelectionnee = terme;
    });
    
    document.getElementById('shapes-container').appendChild(shapeElement);
  });
  
  console.log('D√©finition affich√©e :', window.definitionActuelle);
}

// V√©rifier la r√©ponse s√©lectionn√©e
function verifierReponseDefinition() {
  console.log('V√©rification de la r√©ponse');
  
  if (!window.reponseSelectionnee) {
    document.getElementById('feedback-def').textContent = 'Veuillez s√©lectionner une r√©ponse';
    document.getElementById('feedback-def').style.color = 'red';
    return;
  }
  
  const feedbackElement = document.getElementById('feedback-def');
  
  if (window.reponseSelectionnee === window.reponseCorrecte) {
    // Bonne r√©ponse
    window.scoreDefinitions++;
    feedbackElement.textContent = 'Bravo ! Bonne r√©ponse !';
    feedbackElement.style.color = 'green';
    document.getElementById('score-definitions').textContent = window.scoreDefinitions;
  } else {
    // Mauvaise r√©ponse
    feedbackElement.textContent = `Incorrect. La bonne r√©ponse √©tait : ${window.reponseCorrecte}`;
    feedbackElement.style.color = 'red';
  }
  
  // Mettre √† jour l'interface
  document.getElementById('verifier-def').style.display = 'none';
  document.getElementById('suivant-def').style.display = 'inline-block';
  
  // Mettre en √©vidence la bonne r√©ponse
  document.querySelectorAll('.shape-item').forEach(item => {
    if (item.dataset.terme === window.reponseCorrecte) {
      item.classList.add('correct-answer');
    }
  });
}

// Initialisation du jeu de g√©om√©trie
function initialiserJeuGeometrie() {
  console.log('=== D√âBUT initialiserJeuGeometrie ===');
  
  // R√©initialiser les variables du jeu
  window.formesJouees = [];
  window.scoreGeometrie = 0;
  window.reponseSelectionnee = null;
  
  // Afficher un indicateur de chargement
  const container = document.querySelector('.game-geometrie');
  if (container) {
    container.innerHTML = '<div class="loading">Chargement du jeu de g√©om√©trie...</div>';
  }
  
  // V√©rifier si les donn√©es sont d√©j√† charg√©es
  if (window.geometrieData) {
    console.log('Donn√©es de g√©om√©trie d√©j√† charg√©es en m√©moire');
    afficherInterfaceJeu();
    return;
  }
  
  // Charger les donn√©es de g√©om√©trie
  console.log('Chargement des donn√©es de g√©om√©trie depuis le fichier...');
  
  // V√©rifier si la fonction chargerDonneesGeometrie existe
  if (typeof chargerDonneesGeometrie !== 'function') {
    const errorMsg = 'La fonction chargerDonneesGeometrie n\'est pas d√©finie';
    console.error(errorMsg);
    if (container) {
      container.innerHTML = `<div class="error">${errorMsg}</div>`;
    }
    return;
  }
  
  // Appeler la fonction de chargement des donn√©es
  chargerDonneesGeometrie()
    .then(() => {
      console.log('Donn√©es de g√©om√©trie charg√©es avec succ√®s:', window.geometrieData);
      
      // V√©rifier que les donn√©es sont valides
      if (!window.geometrieData || !window.geometrieData.niveaux || !Array.isArray(window.geometrieData.niveaux)) {
        throw new Error('Format de donn√©es invalide. V√©rifiez le fichier geometrie.json');
      }
      
      console.log(`Nombre de niveaux charg√©s: ${window.geometrieData.niveaux.length}`);
      
      // Afficher l'interface du jeu
      afficherInterfaceJeu();
    })
    .catch(error => {
      const errorMsg = `Erreur lors du chargement des donn√©es de g√©om√©trie: ${error.message}`;
      console.error(errorMsg, error);
      
      if (container) {
        container.innerHTML = `
          <div class="error">
            <p>${errorMsg}</p>
            <button onclick="window.location.reload()">R√©essayer</button>
          </div>`;
      }
    });
}

// Afficher l'interface du jeu de g√©om√©trie
function afficherInterfaceJeu() {
  console.log('Affichage de l\'interface du jeu de g√©om√©trie...');
  
  const container = document.querySelector('.game-geometrie');
  if (!container) {
    console.error('Conteneur du jeu de g√©om√©trie non trouv√©');
    return;
  }
  
  // V√©rifier que les donn√©es sont disponibles
  if (!window.geometrieData || !window.geometrieData.niveaux) {
    container.innerHTML = `
      <div class="error">
        <p>Aucune donn√©e de niveau disponible. V√©rifiez le fichier de configuration.</p>
        <button onclick="window.location.reload()">R√©essayer</button>
      </div>`;
    return;
  }
  
  // Afficher l'interface de s√©lection des niveaux
  container.innerHTML = `
    <div class="niveau-selection">
      <h2>Choisissez un niveau</h2>
      <div class="niveaux-container">
        ${window.geometrieData.niveaux.map(niveau => `
          <button 
            class="niveau-btn" 
            data-niveau="${niveau.id}"
            ${niveau.disabled ? 'disabled' : ''}
          >
            <span class="niveau-titre">${niveau.nom || 'Niveau sans nom'}</span>
            <span class="niveau-description">${niveau.description || ''}</span>
          </button>
        `).join('')}
      </div>
    </div>
    <div id="jeu-geometrie" style="display: none;">
      <div class="jeu-header">
        <h2 id="niveau-titre"></h2>
        <p id="niveau-description" class="niveau-description"></p>
      </div>
      <div class="jeu-contenu">
        <div id="forme-container" class="forme-container"></div>
        <div id="reponse-container" class="reponse-container">
          <div id="reponse-boutons" class="reponse-boutons"></div>
          <div id="feedback" class="feedback">
            <p id="feedback-texte"></p>
            <p id="explication" class="explication"></p>
            <div id="definition" class="definition">
              <h3>D√©finition :</h3>
              <p id="definition-texte"></p>
            </div>
          </div>
        </div>
      </div>
      <div class="jeu-actions">
        <button id="btn-valider" class="btn-valider">Valider</button>
        <button id="btn-suivant" class="btn-suivant" style="display: none;">Forme suivante</button>
        <button id="btn-recommencer" class="btn-recommencer">Recommencer</button>
      </div>
      <div id="resultats" class="resultats" style="display: none;">
        <h3>R√©sultats</h3>
        <p>Votre score: <span id="score">0</span> / <span id="total">0</span></p>
        <p id="message-score" class="message-score"></p>
        <button id="btn-nouvelle-partie" class="btn-nouvelle-partie">Nouvelle partie</button>
      </div>
    </div>`;
    
  // Configurer les boutons
  configurerBoutonsNiveaux();
  
  // Configurer le bouton de retour
  const btnRetour = document.createElement('button');
  btnRetour.className = 'btn-retour';
  btnRetour.innerHTML = '&larr; Retour √† la s√©lection des niveaux';
  btnRetour.onclick = () => {
    const selectionNiveau = document.querySelector('.niveau-selection');
    const interfaceJeu = document.getElementById('jeu-geometrie');
    
    if (selectionNiveau) selectionNiveau.style.display = 'block';
    if (interfaceJeu) interfaceJeu.style.display = 'none';
  };
  
  const jeuHeader = document.querySelector('.jeu-header');
  if (jeuHeader) {
    jeuHeader.insertBefore(btnRetour, jeuHeader.firstChild);
  }
  
  console.log('Interface du jeu de g√©om√©trie affich√©e avec succ√®s');
}

// Configurer les boutons de niveau
function configurerBoutonsNiveaux() {
  console.log('D√©but de la configuration des boutons de niveau...');
  
  // V√©rifier si les donn√©es de g√©om√©trie sont disponibles
  if (!window.geometrieData) {
    console.error('Erreur: Donn√©es de g√©om√©trie non charg√©es');
    return;
  }
  
  // S√©lectionner tous les boutons de niveau
  const boutonsNiveau = document.querySelectorAll('.niveau-btn');
  console.log(`Nombre de boutons de niveau trouv√©s: ${boutonsNiveau.length}`);
  
  if (boutonsNiveau.length === 0) {
    console.error('Aucun bouton de niveau trouv√© avec la classe "niveau-btn"');
    return;
  }
  
  // Afficher des informations sur chaque bouton trouv√©
  boutonsNiveau.forEach((btn, index) => {
    const niveauId = btn.getAttribute('data-niveau');
    console.log(`Bouton ${index + 1}:`, {
      id: btn.id,
      'data-niveau': niveauId,
      text: btn.textContent.trim(),
      'class': btn.className
    });
  });
  
  // Ajouter les √©couteurs d'√©v√©nements pour les boutons de niveau
  boutonsNiveau.forEach(btn => {
    const niveauId = btn.getAttribute('data-niveau');
    
    // Supprimer d'abord tout √©couteur existant pour √©viter les doublons
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);
    
    // Ajouter le nouvel √©couteur
    newBtn.addEventListener('click', (e) => {
      e.preventDefault();
      const niveauId = e.currentTarget.getAttribute('data-niveau');
      console.log('Niveau s√©lectionn√©:', niveauId);
      
      if (!niveauId) {
        console.error('Aucun ID de niveau trouv√© sur le bouton');
        return;
      }
      
      // Masquer la s√©lection de niveau et afficher le jeu
      const selectionNiveau = document.querySelector('.niveau-selection');
      const interfaceJeu = document.getElementById('jeu-geometrie');
      
      if (selectionNiveau) selectionNiveau.style.display = 'none';
      if (interfaceJeu) interfaceJeu.style.display = 'block';
      
      // D√©marrer le niveau s√©lectionn√©
      demarrerNiveau(niveauId);
    });
    
    // Activer le bouton
    newBtn.disabled = false;
    newBtn.style.opacity = '1';
    newBtn.style.cursor = 'pointer';
    console.log(`√âcouteur d'√©v√©nement ajout√© pour le bouton:`, niveauId);
  });
  
  // Ajouter les √©couteurs d'√©v√©nements pour les boutons d'action
  const btnValider = document.getElementById('btn-valider');
  const btnSuivant = document.getElementById('btn-suivant');
  const btnRecommencer = document.getElementById('btn-recommencer'); // Corrig√©: utilisation du bon ID
  
  if (btnValider) {
    // Supprimer d'abord tout √©couteur existant pour √©viter les doublons
    btnValider.replaceWith(btnValider.cloneNode(true));
    document.getElementById('btn-valider').addEventListener('click', validerReponse);
    console.log('√âcouteur ajout√© sur le bouton Valider');
  } else {
    console.error('Bouton valider non trouv√©');
  }
  
  if (btnSuivant) {
    // Supprimer d'abord tout √©couteur existant pour √©viter les doublons
    btnSuivant.replaceWith(btnSuivant.cloneNode(true));
    document.getElementById('btn-suivant').addEventListener('click', afficherFormeSuivante);
    console.log('√âcouteur ajout√© sur le bouton Suivant');
  } else {
    console.error('Bouton suivant non trouv√©');
  }
  
  if (btnRecommencer) {
    // Supprimer d'abord tout √©couteur existant pour √©viter les doublons
    btnRecommencer.replaceWith(btnRecommencer.cloneNode(true));
    document.getElementById('btn-recommencer').addEventListener('click', recommencerNiveau);
    console.log('√âcouteur ajout√© sur le bouton Recommencer');
  } else {
    console.error('Bouton recommencer non trouv√©');
  }
  
  console.log('Boutons configur√©s avec succ√®s');
}

// D√©marrer un niveau sp√©cifique
function demarrerNiveau(niveauId) {
  console.log('=== D√âMARRAGE DU NIVEAU ===');
  console.log('ID du niveau:', niveauId);
  
  // V√©rifier si les donn√©es sont charg√©es
  if (!window.geometrieData || !window.geometrieData.niveaux) {
    const errorMsg = 'Erreur: Donn√©es de g√©om√©trie non charg√©es';
    console.error(errorMsg);
    afficherErreur(errorMsg);
    return;
  }
  
  console.log('Nombre total de niveaux disponibles:', window.geometrieData.niveaux.length);
  
  // Trouver le niveau correspondant
  const niveau = window.geometrieData.niveaux.find(n => n.id === niveauId);
  
  if (!niveau) {
    const errorMsg = `Erreur: Niveau "${niveauId}" non trouv√©`;
    console.error(errorMsg);
    console.log('Niveaux disponibles:', window.geometrieData.niveaux.map(n => n.id));
    afficherErreur(errorMsg);
    return;
  }
  
  console.log('Niveau trouv√©:', niveau);
  
  // V√©rifier que le niveau a des formes
  if (!niveau.formes || !Array.isArray(niveau.formes) || niveau.formes.length === 0) {
    const errorMsg = `Erreur: Aucune forme d√©finie pour le niveau "${niveauId}"`;
    console.error(errorMsg);
    afficherErreur(errorMsg);
    return false;
  }
  
  console.log(`Nombre de formes dans ce niveau: ${niveau.formes.length}`);
  
  try {
    // Mettre √† jour l'interface utilisateur
    const titreElement = document.getElementById('niveau-titre');
    const descriptionElement = document.getElementById('niveau-description');
    
    if (titreElement) titreElement.textContent = niveau.nom || 'Niveau sans nom';
    if (descriptionElement) descriptionElement.textContent = niveau.description || '';
    
    // R√©initialiser les variables du jeu
    window.formesJouees = [];
    window.scoreGeometrie = 0;
    window.reponseSelectionnee = null;
    window.formesRestantes = [];
    
    // Cr√©er une copie des formes disponibles pour ce niveau
    window.formesDisponibles = JSON.parse(JSON.stringify(niveau.formes));
    
    // M√©langer les formes pour ce niveau
    melangerTableau(window.formesDisponibles);
    
    console.log('Formes disponibles apr√®s m√©lange:', window.formesDisponibles);
    
    // Mettre √† jour le score
    const scoreElement = document.getElementById('score');
    const totalElement = document.getElementById('total');
    
    if (scoreElement) scoreElement.textContent = '0';
    if (totalElement) totalElement.textContent = window.formesDisponibles.length.toString();
    
    // Afficher le conteneur du jeu
    const jeuElement = document.getElementById('jeu-geometrie');
    const selectionNiveau = document.querySelector('.niveau-selection');
    
    console.log('Jeu √©l√©ment:', jeuElement);
    console.log('S√©lection niveau:', selectionNiveau);
    
    if (selectionNiveau) {
      console.log('Masquage de la s√©lection de niveau');
      selectionNiveau.style.display = 'none';
    } else {
      console.warn('√âl√©ment de s√©lection de niveau non trouv√©');
    }
    
    if (jeuElement) {
      console.log('Affichage du jeu de g√©om√©trie');
      jeuElement.style.display = 'block';
      
      // V√©rifier la visibilit√© du conteneur
      const style = window.getComputedStyle(jeuElement);
      console.log('Style du jeu:', {
        display: style.display,
        visibility: style.visibility,
        opacity: style.opacity
      });
    } else {
      console.error('√âl√©ment du jeu de g√©om√©trie non trouv√©');
    }
    
    // Masquer les r√©sultats
    const resultatsElement = document.getElementById('resultats');
    if (resultatsElement) resultatsElement.style.display = 'none';
    
    // R√©initialiser le feedback
    const feedbackElement = document.getElementById('feedback');
    const btnValider = document.getElementById('btn-valider');
    const btnSuivant = document.getElementById('btn-suivant');
    
    if (feedbackElement) feedbackElement.style.display = 'none';
    if (btnValider) btnValider.style.display = 'inline-block';
    if (btnSuivant) btnSuivant.style.display = 'none';
    
    // Mettre √† jour les variables globales
    window.niveauActuel = niveauId;
    window.formeActuelle = window.formesDisponibles[0];
    
    // Afficher la premi√®re forme
    console.log('Affichage de la premi√®re forme...');
    afficherFormeAleatoire();
    
  } catch (error) {
    const errorMsg = `Erreur lors du d√©marrage du niveau: ${error.message}`;
    console.error(errorMsg, error);
    afficherErreur(errorMsg);
  }
}

// Afficher une erreur dans l'interface utilisateur
function afficherErreur(message) {
  console.error('=== ERREUR ===', message);
  
  // Essayer d'afficher dans l'√©l√©ment de feedback s'il existe
  const feedback = document.getElementById('feedback');
  const feedbackTexte = document.getElementById('feedback-texte');
  
  if (feedback && feedbackTexte) {
    feedback.className = 'feedback error';
    feedbackTexte.textContent = message;
    feedback.style.display = 'block';
    
    // Faire d√©filer vers le haut de la page pour que l'erreur soit visible
    window.scrollTo({ top: 0, behavior: 'smooth' });
    return;
  }
  
  // Si l'√©l√©ment de feedback n'est pas disponible, essayer d'afficher dans un conteneur de jeu
  const container = document.querySelector('.game-geometrie');
  if (container) {
    // Cr√©er un √©l√©ment d'erreur s'il n'existe pas d√©j√†
    let errorElement = container.querySelector('.error-message');
    
    if (!errorElement) {
      errorElement = document.createElement('div');
      errorElement.className = 'error-message';
      container.insertBefore(errorElement, container.firstChild);
    }
    
    errorElement.innerHTML = `
      <div class="alert alert-danger" role="alert">
        <strong>Erreur :</strong> ${message}
        <button type="button" class="close" onclick="this.parentElement.style.display='none'">
          &times;
        </button>
      </div>
    `;
    
    // Faire d√©filer vers le haut de la page pour que l'erreur soit visible
    window.scrollTo({ top: 0, behavior: 'smooth' });
    return;
  }
  
  // Si aucun conteneur n'est disponible, afficher une alerte
  console.error('Impossible d\'afficher l\'erreur dans l\'interface');
  alert(`Erreur : ${message}`);
}

// M√©langer les √©l√©ments d'un tableau de mani√®re al√©atoire (algorithme de Fisher-Yates)
function melangerTableau(tableau) {
  if (!Array.isArray(tableau)) {
    console.error('Erreur: L\'argument doit √™tre un tableau');
    return [];
  }
  
  const resultat = [...tableau];
  for (let i = resultat.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [resultat[i], resultat[j]] = [resultat[j], resultat[i]]; // √âchange des √©l√©ments
  }
  return resultat;
}

// Afficher une forme al√©atoire
function afficherFormeAleatoire() {
  console.log('=== AFFICHAGE D\'UNE FORME AL√âATOIRE ===');
  
  // V√©rifier que les donn√©es sont charg√©es
  if (!window.geometrieData || !window.formesDisponibles) {
    console.error('Erreur: Donn√©es de g√©om√©trie non charg√©es');
    afficherErreur('Impossible de charger les donn√©es du jeu. Veuillez r√©essayer.');
    return;
  }
  
  // V√©rifier s'il reste des formes √† jouer
  if (window.formesDisponibles.length === 0) {
    console.log('Toutes les formes ont √©t√© jou√©es, affichage des r√©sultats...');
    afficherResultats();
    return;
  }
  
  try {
    // S√©lectionner et retirer une forme al√©atoire du tableau
    const randomIndex = Math.floor(Math.random() * window.formesDisponibles.length);
    const forme = window.formesDisponibles.splice(randomIndex, 1)[0];
    
    if (!forme) {
      throw new Error('Aucune forme valide disponible');
    }
    
    console.log('Forme s√©lectionn√©e:', forme);
    
    // Stocker la forme actuelle
    window.formeActuelle = forme;
    
    // Mettre √† jour le compteur de progression
    const progression = document.getElementById('progression');
    if (progression) {
      const formesRestantes = window.formesDisponibles.length + 1;
      const totalFormes = formesRestantes + (window.formesJouees ? window.formesJouees.length : 0);
      progression.textContent = `Question ${totalFormes - formesRestantes + 1} sur ${totalFormes}`;
    }
    
    // V√©rifier que les √©l√©ments n√©cessaires sont pr√©sents
    console.log('Niveau actuel:', window.niveauActuel);
    console.log('Forme actuelle:', window.formeActuelle);
    
    if (!window.niveauActuel || !window.formeActuelle) {
      throw new Error('Donn√©es manquantes pour afficher la forme');
    }
    
    // R√©initialiser l'interface
    const feedbackElement = document.getElementById('feedback');
    const btnValider = document.getElementById('btn-valider');
    const btnSuivant = document.getElementById('btn-suivant');
    const definitionElement = document.getElementById('definition');
    
    // R√©initialiser la s√©lection de r√©ponse
    window.reponseSelectionnee = null;
    
    // Mettre √† jour l'interface
    const formeContainer = document.getElementById('forme-container');
    const reponsesContainer = document.getElementById('reponse-boutons-container');
    
    console.log('=== V√âRIFICATION DU DOM ===');
    console.log('Conteneur de forme:', formeContainer);
    
    // V√©rifier si le conteneur de r√©ponses existe dans le DOM
    if (!reponsesContainer) {
      console.error('ERREUR: Le conteneur de r√©ponses n\'a pas √©t√© trouv√© dans le DOM');
      console.log('Recherche de tous les √©l√©ments avec la classe "reponse-boutons":', 
                 document.querySelectorAll('.reponse-boutons'));
      return; // Arr√™ter l'ex√©cution si le conteneur n'existe pas
    }
    
    console.log('Conteneur de r√©ponses trouv√©:', reponsesContainer);
    console.log('Parent du conteneur de r√©ponses:', reponsesContainer.parentElement);
    console.log('HTML du conteneur avant modification:', reponsesContainer.outerHTML);
    
    // V√©rifier si le conteneur est visible
    const style = window.getComputedStyle(reponsesContainer);
    console.log('Style du conteneur de r√©ponses:', {
      display: style.display,
      visibility: style.visibility,
      opacity: style.opacity,
      height: style.height,
      width: style.width
    });
    
    // Forcer l'affichage pour le d√©bogage
    reponsesContainer.style.display = 'block';
    reponsesContainer.style.visibility = 'visible';
    reponsesContainer.style.opacity = '1';
    
    if (formeContainer) {
      // Afficher l'image de la forme
      const imageUrl = `images/geometrie/${window.formeActuelle.image || 'forme-inconnue.svg'}`;
      formeContainer.innerHTML = `
        <div class="forme-image-container">
          <img src="${imageUrl}" alt="${window.formeActuelle.type || 'Forme g√©om√©trique'}" class="forme-image" 
               onerror="this.onerror=null; this.src='images/geometrie/forme-inconnue.svg';">
        </div>
      `;
    }
    
    if (reponsesContainer) {
      // Vider les boutons de r√©ponse pr√©c√©dents
      reponsesContainer.innerHTML = '';
      
      // D√©terminer les r√©ponses possibles en fonction du niveau
      let reponses = [];
      
      if (window.niveauActuel.id === 'polygone-ou-non') {
        // Niveau 1: Polygone ou non
        reponses = [
          { texte: 'Oui, c\'est un polygone', correct: window.formeActuelle.estPolygone === true },
          { texte: 'Non, ce n\'est pas un polygone', correct: window.formeActuelle.estPolygone === false }
        ];
      } else if (window.niveauActuel.id === 'type-polygone') {
        // Niveau 2: Type de polygone
        const estTriangle = window.formeActuelle.cotes === 3;
        reponses = [
          { texte: 'Triangle', correct: estTriangle },
          { texte: 'Quadrilat√®re', correct: !estTriangle }
        ];
      } else if (window.niveauActuel.id === 'quadrilateres') {
        // Niveau 3: Types de quadrilat√®res
        reponses = [
          { texte: 'Carr√©', correct: window.formeActuelle.type === 'carre' },
          { texte: 'Rectangle', correct: window.formeActuelle.type === 'rectangle' },
          { texte: 'Losange', correct: window.formeActuelle.type === 'losange' },
          { texte: 'Parall√©logramme', correct: window.formeActuelle.type === 'parallelogramme' },
          { texte: 'Trap√®ze', correct: window.formeActuelle.type === 'trapeze' }
        ];
      } else {
        console.warn('Type de niveau non reconnu:', window.niveauActuel.id);
        reponses = [];
      }
      
      // M√©langer les r√©ponses pour √©viter un ordre pr√©visible
      melangerTableau(reponses);
      
      // Cr√©er les boutons de r√©ponse
      console.log('=== CR√âATION DES BOUTONS ===');
      console.log('R√©ponses √† afficher:', reponses);
      
      // V√©rifier que reponses est un tableau non vide
      if (!Array.isArray(reponses) || reponses.length === 0) {
        console.error('ERREUR: Aucune r√©ponse √† afficher');
        // Afficher le message d'erreur
        const messageAucunBouton = document.getElementById('message-aucun-bouton');
        if (messageAucunBouton) {
          messageAucunBouton.style.display = 'block';
          messageAucunBouton.textContent = 'Aucune r√©ponse disponible pour cette question';
        }
        return;
      } else {
        // Cacher le message d'erreur s'il y a des r√©ponses
        const messageAucunBouton = document.getElementById('message-aucun-bouton');
        if (messageAucunBouton) {
          messageAucunBouton.style.display = 'none';
        }
      }
      
      // Vider d'abord le conteneur
      reponsesContainer.innerHTML = '';
      
      // Cr√©er un fragment pour optimiser les performances
      const fragment = document.createDocumentFragment();
      
      // CIBLE_DEBUT_AJOUT_BOUTONS
      
      reponses.forEach((reponse, index) => {
        try {
          console.log(`Cr√©ation du bouton ${index}:`, reponse.texte);
          
          // Cr√©er le bouton
          const bouton = document.createElement('button');
          bouton.className = 'btn-reponse';
          bouton.textContent = reponse.texte;
          bouton.dataset.correct = reponse.correct;
          bouton.dataset.index = index;
          
          // Ajouter un style temporaire pour le d√©bogage
          bouton.style.margin = '5px';
          bouton.style.padding = '10px';
          bouton.style.border = '2px solid blue';
          
          console.log('Bouton cr√©√©:', {
            texte: bouton.textContent,
            classes: bouton.className,
            dataset: bouton.dataset,
            parent: bouton.parentElement
          });
          
          // Ajouter un √©couteur d'√©v√©nements
          bouton.addEventListener('click', function() {
            console.log(`Bouton cliqu√©: ${this.textContent}`);
            
            // D√©s√©lectionner tous les boutons
            document.querySelectorAll('.btn-reponse').forEach(btn => {
              btn.classList.remove('selected');
            });
            
            // S√©lectionner le bouton cliqu√©
            this.classList.add('selected');
            window.reponseSelectionnee = {
              index: index,
              correct: reponse.correct,
              texte: reponse.texte
            };
            
            console.log('R√©ponse s√©lectionn√©e:', window.reponseSelectionnee);
            
            // Activer le bouton Valider
            if (btnValider) {
              btnValider.disabled = false;
            }
          });
          
          // Ajouter le bouton au fragment
          console.log('Ajout du bouton au fragment...');
          fragment.appendChild(bouton);
          console.log('Bouton ajout√© au fragment avec succ√®s.');
          
        } catch (error) {
          console.error(`Erreur lors de la cr√©ation du bouton ${index}:`, error);
        }
      });
    }
    
    // Mettre √† jour les boutons d'action
    if (btnValider) {
      btnValider.disabled = true;
      btnValider.style.display = 'inline-block';
    }
    
    if (btnSuivant) {
      btnSuivant.style.display = 'none';
    }
    
    if (feedbackElement) {
      feedbackElement.style.display = 'none';
    }
    
    if (definitionElement) {
      definitionElement.style.display = 'none';
    }
    
    // Ajouter la forme √† la liste des formes jou√©es
    if (!window.formesJouees) {
      window.formesJouees = [];
    }
    window.formesJouees.push(window.formeActuelle);
    
  } catch (error) {
    console.error('Erreur lors de l\'affichage d\'une forme al√©atoire:', error);
    afficherErreur('Une erreur est survenue lors du chargement de la forme. Veuillez r√©essayer.');
  }
  
  // Cette partie a √©t√© d√©plac√©e dans la fonction validerReponse
  // qui est appel√©e lorsque l'utilisateur clique sur le bouton Valider
}

// Valider la r√©ponse s√©lectionn√©e par l'utilisateur
function validerReponse() {
  console.log('=== VALIDATION DE LA R√âPONSE ===');
  
  // V√©rifier qu'une r√©ponse a √©t√© s√©lectionn√©e
  if (!window.reponseSelectionnee) {
    console.warn('Aucune r√©ponse s√©lectionn√©e');
    afficherErreur('Veuillez s√©lectionner une r√©ponse avant de valider.');
    return;
  }
  
  // R√©cup√©rer les √©l√©ments d'interface
  const feedback = document.getElementById('feedback');
  const feedbackTexte = document.getElementById('feedback-texte');
  const explication = document.getElementById('explication');
  const definition = document.getElementById('definition');
  const definitionTexte = document.getElementById('definition-texte');
  const btnValider = document.getElementById('btn-valider');
  const btnSuivant = document.getElementById('btn-suivant');
  
  // V√©rifier que les √©l√©ments n√©cessaires sont pr√©sents
  if (!feedback || !feedbackTexte || !explication || !definition || !definitionTexte || !btnValider || !btnSuivant) {
    console.error('√âl√©ments d\'interface manquants');
    afficherErreur('Erreur d\'interface. Veuillez recharger la page.');
    return;
  }
  
  // V√©rifier que la forme actuelle est d√©finie
  if (!window.formeActuelle) {
    console.error('Aucune forme √† valider');
    afficherErreur('Erreur: Aucune forme √† valider.');
    return;
  }
  
  // V√©rifier que le niveau actuel est d√©fini
  if (!window.niveauActuel) {
    console.error('Aucun niveau en cours');
    afficherErreur('Erreur: Aucun niveau en cours.');
    return;
  }
  
  try {
    // D√©terminer si la r√©ponse est correcte et pr√©parer le feedback
    let estCorrect = false;
    let reponseAttendue = '';
    let explicationTexte = '';
    
    // Logique de validation en fonction du niveau
    switch (window.niveauActuel.id) {
      case 'polygone-ou-non':
        reponseAttendue = window.formeActuelle.estPolygone ? 'Oui, c\'est un polygone' : 'Non, ce n\'est pas un polygone';
        estCorrect = window.reponseSelectionnee.texte === reponseAttendue;
        
        if (estCorrect) {
          explicationTexte = window.formeActuelle.estPolygone 
            ? 'Exact ! Cette forme est un polygone car elle est compos√©e de segments droits qui se referment pour former une figure plane ferm√©e.'
            : 'Exact ! Cette forme n\'est pas un polygone car elle contient des courbes ou n\'est pas une figure ferm√©e.';
        } else {
          explicationTexte = window.formeActuelle.estPolygone 
            ? `Non, cette forme est bien un polygone. Un polygone est une figure plane ferm√©e compos√©e de segments droits. ${window.formeActuelle.explication || ''}`
            : `Non, cette forme n'est pas un polygone. ${window.formeActuelle.explication || ''}`;
        }
        break;
        
      case 'type-polygone':
        const estTriangle = window.formeActuelle.cotes === 3;
        reponseAttendue = estTriangle ? 'Triangle' : 'Quadrilat√®re';
        estCorrect = window.reponseSelectionnee.texte === reponseAttendue;
        
        if (estCorrect) {
          explicationTexte = estTriangle 
            ? 'Exact ! Cette forme est un triangle car elle a 3 c√¥t√©s.'
            : 'Exact ! Cette forme est un quadrilat√®re car elle a 4 c√¥t√©s.';
        } else {
          explicationTexte = estTriangle 
            ? `Non, cette forme est un triangle car elle a 3 c√¥t√©s. Un triangle est un polygone √† trois c√¥t√©s.`
            : `Non, cette forme est un quadrilat√®re car elle a 4 c√¥t√©s. Un quadrilat√®re est un polygone √† quatre c√¥t√©s.`;
        }
        break;
        
      case 'quadrilateres':
        const typeForme = window.formeActuelle.type || 'inconnu';
        reponseAttendue = typeForme.charAt(0).toUpperCase() + typeForme.slice(1);
        estCorrect = window.reponseSelectionnee.texte.toLowerCase() === typeForme.toLowerCase();
        
        // D√©finir les explications pour chaque type de quadrilat√®re
        const explications = {
          trapeze: {
            correct: 'Exact ! C\'est un trap√®ze car il a au moins une paire de c√¥t√©s parall√®les.',
            incorrect: 'Non, c\'est un trap√®ze. Un trap√®ze est un quadrilat√®re qui a au moins une paire de c√¥t√©s parall√®les.'
          },
          parallelogramme: {
            correct: 'Exact ! C\'est un parall√©logramme car ses c√¥t√©s oppos√©s sont parall√®les et de m√™me longueur.',
            incorrect: 'Non, c\'est un parall√©logramme. Un parall√©logramme a ses c√¥t√©s oppos√©s parall√®les et de m√™me longueur.'
          },
          rectangle: {
            correct: 'Exact ! C\'est un rectangle car il a quatre angles droits et des c√¥t√©s oppos√©s parall√®les et de m√™me longueur.',
            incorrect: 'Non, c\'est un rectangle. Un rectangle a quatre angles droits et des c√¥t√©s oppos√©s parall√®les et de m√™me longueur.'
          },
          carre: {
            correct: 'Exact ! C\'est un carr√© car il a quatre c√¥t√©s de m√™me longueur et quatre angles droits.',
            incorrect: 'Non, c\'est un carr√©. Un carr√© a quatre c√¥t√©s de m√™me longueur et quatre angles droits.'
          },
          losange: {
            correct: 'Exact ! C\'est un losange car il a quatre c√¥t√©s de m√™me longueur et des c√¥t√©s oppos√©s parall√®les.',
            incorrect: 'Non, c\'est un losange. Un losange a quatre c√¥t√©s de m√™me longueur et des c√¥t√©s oppos√©s parall√®les.'
          }
        };
        
        // Utiliser l'explication correspondante ou une valeur par d√©faut
        const explicationQuadri = explications[typeForme] || {
          correct: 'Bonne r√©ponse !',
          incorrect: `La bonne r√©ponse √©tait : ${reponseAttendue}`
        };
        
        explicationTexte = estCorrect ? explicationQuadri.correct : explicationQuadri.incorrect;
        break;
        
      default:
        console.error('Type de niveau non pris en charge:', window.niveauActuel.id);
        afficherErreur('Type de niveau non pris en charge.');
        return;
    }
    
    // Mettre √† jour le score si la r√©ponse est correcte
    if (estCorrect) {
      window.scoreGeometrie = (window.scoreGeometrie || 0) + 1;
      console.log('Bonne r√©ponse ! Score:', window.scoreGeometrie);
    } else {
      console.log('Mauvaise r√©ponse. La bonne r√©ponse √©tait:', reponseAttendue);
    }
    
    // Mettre √† jour l'affichage du score
    const scoreElement = document.getElementById('score-actuel');
    if (scoreElement) {
      scoreElement.textContent = window.scoreGeometrie || 0;
    }
    
    // Mettre √† jour l'interface utilisateur
    feedback.className = estCorrect ? 'feedback correct' : 'feedback incorrect';
    feedbackTexte.textContent = estCorrect ? 'Bonne r√©ponse !' : `La bonne r√©ponse √©tait : ${reponseAttendue}`;
    explication.textContent = explicationTexte;
    
    // Afficher la d√©finition si disponible
    if (window.geometrieData?.definitions?.[window.formeActuelle.type]) {
      definitionTexte.textContent = window.geometrieData.definitions[window.formeActuelle.type];
      definition.style.display = 'block';
    } else {
      definition.style.display = 'none';
    }
    
    // Afficher le feedback
    feedback.style.display = 'block';
    
    // D√©sactiver tous les boutons de r√©ponse
    const boutonsReponse = document.querySelectorAll('.btn-reponse');
    boutonsReponse.forEach(btn => {
      btn.disabled = true;
      
      // Mettre en √©vidence la bonne r√©ponse
      if (btn.textContent.toLowerCase() === reponseAttendue.toLowerCase()) {
        btn.classList.add('correct-answer');
      }
    });
    
    // Mettre √† jour les boutons d'action
    btnValider.style.display = 'none';
    btnSuivant.style.display = 'inline-block';
    
    // Ajouter la forme √† l'historique des formes jou√©es
    if (!window.formesJouees) {
      window.formesJouees = [];
    }
    window.formesJouees.push({
      ...window.formeActuelle,
      reponseDonnee: window.reponseSelectionnee.texte,
      estCorrecte: estCorrect,
      date: new Date().toISOString()
    });
    
    console.log('Forme ajout√©e √† l\'historique:', window.formesJouees[window.formesJouees.length - 1]);
    
  } catch (error) {
    console.error('Erreur lors de la validation de la r√©ponse:', error);
    afficherErreur('Une erreur est survenue lors de la validation de votre r√©ponse. Veuillez r√©essayer.');
  }
}

// Afficher la forme suivante
function afficherFormeSuivante() {
  console.log('=== PASSAGE √Ä LA FORME SUIVANTE ===');
  
  try {
    // V√©rifier qu'il reste des formes √† afficher
    const formesRestantes = window.formesDisponibles ? window.formesDisponibles.length : 0;
    const totalJouees = window.formesJouees ? window.formesJouees.length : 0;
    
    console.log(`Formes restantes: ${formesRestantes}, d√©j√† jou√©es: ${totalJouees}`);
    
    if (formesRestantes === 0) {
      console.log('Toutes les formes ont √©t√© jou√©es, affichage des r√©sultats');
      afficherResultats();
      return;
    }
    
    // R√©initialiser la s√©lection de r√©ponse
    window.reponseSelectionnee = null;
    
    // Masquer le feedback pr√©c√©dent
    const feedback = document.getElementById('feedback');
    const definition = document.getElementById('definition');
    
    if (feedback) feedback.style.display = 'none';
    if (definition) definition.style.display = 'none';
    
    // Mettre √† jour les boutons d'action
    const btnValider = document.getElementById('btn-valider');
    const btnSuivant = document.getElementById('btn-suivant');
    
    if (btnValider) {
      btnValider.disabled = true;
      btnValider.style.display = 'inline-block';
    }
    
    if (btnSuivant) {
      btnSuivant.style.display = 'none';
    }
    
    // Afficher une nouvelle forme
    afficherFormeAleatoire();
    
  } catch (error) {
    console.error('Erreur lors du passage √† la forme suivante:', error);
    
    // Afficher un message d'erreur √† l'utilisateur
    const feedback = document.getElementById('feedback');
    const feedbackTexte = document.getElementById('feedback-texte');
    
    if (feedback && feedbackTexte) {
      feedback.className = 'feedback error';
      feedbackTexte.textContent = 'Une erreur est survenue lors du chargement de la prochaine forme.';
      feedback.style.display = 'block';
    } else {
      console.error('Impossible d\'afficher le message d\'erreur: √©l√©ments manquants');
    }
    
    // Essayer d'afficher les r√©sultats en cas d'erreur
    try {
      afficherResultats();
    } catch (e) {
      console.error('Impossible d\'afficher les r√©sultats:', e);
      
      // En dernier recours, recharger la page
      if (confirm('Une erreur est survenue. Voulez-vous recharger la page ?')) {
        window.location.reload();
      }
    }
  }
}



// Afficher les r√©sultats finaux
function afficherResultats() {
  console.log('=== AFFICHAGE DES R√âSULTATS FINAUX ===');
  
  try {
    // Masquer les √©l√©ments du jeu
    const formeContainer = document.getElementById('forme-container');
    const reponsesContainer = document.getElementById('reponse-boutons');
    const feedback = document.getElementById('feedback');
    const definition = document.getElementById('definition');
    const btnValider = document.getElementById('btn-valider');
    const btnSuivant = document.getElementById('btn-suivant');
    
    // Masquer les √©l√©ments non n√©cessaires
    if (formeContainer) formeContainer.style.display = 'none';
    if (reponsesContainer) reponsesContainer.style.display = 'none';
    if (feedback) feedback.style.display = 'none';
    if (definition) definition.style.display = 'none';
    if (btnValider) btnValider.style.display = 'none';
    if (btnSuivant) btnSuivant.style.display = 'none';
    
    // R√©cup√©rer les √©l√©ments d'interface des r√©sultats
    const resultats = document.getElementById('resultats');
    const scoreElement = document.getElementById('score');
    const totalElement = document.getElementById('total');
    const messageElement = document.getElementById('message-score');
    const btnRejouer = document.getElementById('btn-rejouer');
    const btnChangerNiveau = document.getElementById('btn-changer-niveau');
    
    // V√©rifier que les √©l√©ments existent
    if (!resultats || !scoreElement || !totalElement) {
      console.error('√âl√©ments d\'interface des r√©sultats manquants');
      throw new Error('√âl√©ments d\'interface des r√©sultats manquants');
    }
    
    // Calculer les statistiques
    const score = window.scoreGeometrie || 0;
    const total = window.formesJouees ? window.formesJouees.length : 0;
    const pourcentage = total > 0 ? Math.round((score / total) * 100) : 0;
    
    console.log(`R√©sultats: ${score}/${total} (${pourcentage}%)`);
    
    // Mettre √† jour les scores
    scoreElement.textContent = score;
    totalElement.textContent = total;
    
    // Afficher un message personnalis√© en fonction du score
    if (messageElement) {
      if (pourcentage >= 90) {
        messageElement.textContent = 'üåü Excellent travail ! Vous ma√Ætrisez parfaitement ce sujet !';
        messageElement.className = 'excellent';
      } else if (pourcentage >= 70) {
        messageElement.textContent = 'üëç Bravo ! Bonne performance, continuez comme √ßa !';
        messageElement.className = 'bon';
      } else if (pourcentage >= 50) {
        messageElement.textContent = 'üëå Pas mal ! Encore un peu de pratique pour vous perfectionner.';
        messageElement.className = 'moyen';
      } else {
        messageElement.textContent = 'üí™ Ne vous d√©couragez pas ! Revoyez les d√©finitions et r√©essayez.';
        messageElement.className = 'a-ameliorer';
      }
    }
    
    // Configurer les boutons d'action
    if (btnRejouer) {
      btnRejouer.onclick = function() {
        console.log('Nouvelle partie du m√™me niveau demand√©e');
        recommencerNiveau();
      };
    }
    
    if (btnChangerNiveau) {
      btnChangerNiveau.onclick = function() {
        console.log('Changement de niveau demand√©');
        const selectionNiveau = document.querySelector('.niveau-selection');
        const interfaceJeu = document.getElementById('jeu-geometrie');
        
        if (selectionNiveau && interfaceJeu) {
          selectionNiveau.style.display = 'block';
          interfaceJeu.style.display = 'none';
          resultats.style.display = 'none';
          
          // Faire d√©filer vers le haut de la page
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }
      };
    }
    
    // Afficher la section des r√©sultats
    resultats.style.display = 'block';
    
    // Faire d√©filer vers les r√©sultats
    resultats.scrollIntoView({ behavior: 'smooth', block: 'start' });
    
    console.log(`R√©sultats affich√©s: ${score}/${total} (${pourcentage}%)`);
    
  } catch (error) {
    console.error('Erreur lors de l\'affichage des r√©sultats:', error);
    
    // Afficher un message d'erreur √† l'utilisateur
    const feedback = document.getElementById('feedback');
    const feedbackTexte = document.getElementById('feedback-texte');
    
    if (feedback && feedbackTexte) {
      feedback.className = 'feedback error';
      feedbackTexte.textContent = 'Une erreur est survenue lors de l\'affichage des r√©sultats. Veuillez r√©essayer.';
      feedback.style.display = 'block';
    }
    
    // En dernier recours, proposer de recharger la page
    if (confirm('Une erreur est survenue. Voulez-vous recharger la page ?')) {
      window.location.reload();
    }
  }
}

// Recommencer le niveau
function recommencerNiveau() {
  console.log('=== RECOMMENCEMENT DU NIVEAU ===');
  
  try {
    // V√©rifier qu'un niveau est en cours
    if (!window.niveauActuel || !window.niveauActuel.id) {
      console.error('Aucun niveau en cours √† recommencer');
      
      // Essayer de revenir √† la s√©lection de niveau
      const selectionNiveau = document.querySelector('.niveau-selection');
      const interfaceJeu = document.getElementById('jeu-geometrie');
      
      if (selectionNiveau && interfaceJeu) {
        selectionNiveau.style.display = 'block';
        interfaceJeu.style.display = 'none';
      } else {
        console.error('Impossible de trouver les √©l√©ments d\'interface n√©cessaires');
      }
      
      return;
    }
    
    console.log(`Niveau √† recommencer: ${window.niveauActuel.id}`);
    
    // R√©initialiser les variables du jeu
    window.scoreGeometrie = 0;
    window.reponseSelectionnee = null;
    window.formesJouees = [];
    
    // R√©initialiser l'affichage du score
    const scoreElement = document.getElementById('score-actuel');
    if (scoreElement) {
      scoreElement.textContent = '0';
    }
    
    // Masquer les r√©sultats s'ils sont affich√©s
    const resultats = document.getElementById('resultats');
    if (resultats) {
      resultats.style.display = 'none';
    }
    
    // Masquer le feedback et la d√©finition
    const feedback = document.getElementById('feedback');
    const definition = document.getElementById('definition');
    
    if (feedback) feedback.style.display = 'none';
    if (definition) definition.style.display = 'none';
    
    // R√©initialiser les boutons d'action
    const btnValider = document.getElementById('btn-valider');
    const btnSuivant = document.getElementById('btn-suivant');
    
    if (btnValider) {
      btnValider.disabled = true;
      btnValider.style.display = 'inline-block';
    }
    
    if (btnSuivant) {
      btnSuivant.style.display = 'none';
    }
    
    // R√©afficher l'interface de jeu
    const interfaceJeu = document.getElementById('jeu-geometrie');
    if (interfaceJeu) {
      interfaceJeu.style.display = 'block';
    }
    
    // Recharger les donn√©es du niveau
    const niveauId = window.niveauActuel.id;
    
    // R√©initialiser les formes disponibles
    if (window.geometrieData && window.geometrieData.niveaux) {
      const niveau = window.geometrieData.niveaux.find(n => n.id === niveauId);
      if (niveau && niveau.formes) {
        window.formesDisponibles = [...niveau.formes];
        console.log(`${window.formesDisponibles.length} formes charg√©es pour le niveau ${niveauId}`);
      }
    }
    
    // Afficher la premi√®re forme
    afficherFormeAleatoire();
    
    // Faire d√©filer vers le haut de la zone de jeu
    window.scrollTo({ top: 0, behavior: 'smooth' });
    
  } catch (error) {
    console.error('Erreur lors du recommencement du niveau:', error);
    
    // Afficher un message d'erreur √† l'utilisateur
    const feedback = document.getElementById('feedback');
    const feedbackTexte = document.getElementById('feedback-texte');
    
    if (feedback && feedbackTexte) {
      feedback.className = 'feedback error';
      feedbackTexte.textContent = 'Une erreur est survenue lors du recommencement du niveau. Veuillez r√©essayer.';
      feedback.style.display = 'block';
    }
    
    // Essayer de revenir √† la s√©lection de niveau
    try {
      const selectionNiveau = document.querySelector('.niveau-selection');
      const interfaceJeu = document.getElementById('jeu-geometrie');
      
      if (selectionNiveau) {
        selectionNiveau.style.display = 'block';
      }
      
      if (interfaceJeu) {
        interfaceJeu.style.display = 'none';
      }
    } catch (e) {
      console.error('Impossible de revenir √† la s√©lection de niveau:', e);
      
      // En dernier recours, recharger la page
      if (confirm('Une erreur est survenue. Voulez-vous recharger la page ?')) {
        window.location.reload();
      }
    }
  }
}

// Ajouter les √©couteurs d'√©v√©nements pour le jeu de conjugaison
document.addEventListener('DOMContentLoaded', function() {
  // Initialisation du menu
  const menuBtn = document.querySelector('.menu-btn');
  if (menuBtn) {
    menuBtn.addEventListener('click', toggleMenu);
  }
  
  // Initialisation du jeu de g√©om√©trie
  initialiserJeuGeometrie();
  
  const checkBtn = document.getElementById('check-conjugaison');
  const nextBtn = document.getElementById('next-conjugaison');
  
  if (checkBtn) {
    checkBtn.addEventListener('click', checkConjugaison);
  }
  
  if (nextBtn) {
    nextBtn.addEventListener('click', nextVerbe);
  }
  
  // Valider la conjugaison avec la touche Entr√©e
  document.querySelectorAll('.conjugaison-input').forEach(input => {
    input.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        checkConjugaison();
      }
    });
  });
  
  // Initialiser le jeu de conjugaison
  initConjugaison();
});
</script>
</body>
</html>
