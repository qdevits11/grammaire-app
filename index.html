<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>R√©vision Grammaire</title>
  <link rel="stylesheet" href="style.css">
  <script>
  // Fonction pour m√©langer un tableau (algorithme de Fisher-Yates)
  function melangerTableau(tableau) {
    const resultat = [...tableau];
    for (let i = resultat.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [resultat[i], resultat[j]] = [resultat[j], resultat[i]];
    }
    return resultat;
  }
  
  // D√©finition de la fonction checkFutur en premier
  function checkFutur(answer, game = 'futur') {
    console.log('=== FONCTION checkFutur APPEL√âE ===');
    console.log('Bouton cliqu√©:', answer);
    
    // Attendre que l'objet games soit disponible
    if (!window.games) {
      console.error('L\'objet games n\'est pas encore charg√©');
      return;
    }
    
    const gameData = window.games[game];
    if (!gameData) {
      console.error('Jeu non trouv√©:', game, 'Disponibles:', Object.keys(window.games));
      return;
    }
    
    // V√©rifier que l'index actuel est valide
    if (typeof gameData.current === 'undefined' || gameData.current === null) {
      console.error('Index actuel non d√©fini, r√©initialisation...');
      gameData.current = 0;
    }
    
    let currentData = gameData.data[gameData.current];
    if (!currentData) {
      console.error('Aucune donn√©e pour la phrase actuelle. Index:', gameData.current, 'Donn√©es:', gameData.data);
      // Essayer de r√©cup√©rer la premi√®re phrase
      if (gameData.data.length > 0) {
        console.log('Tentative de r√©cup√©ration de la premi√®re phrase...');
        gameData.current = 0;
        currentData = gameData.data[0];
      } else {
        return;
      }
    }
    
    console.log('Index actuel:', gameData.current, '/', gameData.data.length - 1);
    console.log('Toutes les donn√©es:', gameData.data);
    
    console.log('Donn√©es de la phrase actuelle:', currentData);
    
    const feedbackElement = document.getElementById('futur-feedback');
    
    // V√©rifier la r√©ponse
    const expectedAnswer = currentData.type;
    console.log('R√©ponse attendue:', expectedAnswer, 'R√©ponse donn√©e:', answer);
    
    if (answer === expectedAnswer) {
      console.log('Bonne r√©ponse');
      feedbackElement.textContent = '‚úÖ Bonne r√©ponse ! +1 point';
      feedbackElement.style.color = 'green';
      gameData.totalPoints++;
    } else {
      console.log('Mauvaise r√©ponse');
      feedbackElement.textContent = `‚ùå Faux ! La bonne r√©ponse √©tait "${expectedAnswer}" -1 point`;
      feedbackElement.style.color = 'red';
      
      // Enlever un point (mais ne pas descendre en dessous de 0)
      if (gameData.totalPoints > 0) {
        gameData.totalPoints--;
      }
      gameData.totalErreurs++;
      
      // Jouer un son d'erreur
      const sound = document.getElementById('sound-bad');
      if (sound) {
        sound.currentTime = 0;
        sound.play().catch(e => console.error('Erreur de lecture du son:', e));
      }
    }
    
    // Mettre √† jour le tableau des scores
    updateScoreboard(game);
    
    // D√©sactiver tous les boutons sauf suivant
    const buttons = document.querySelectorAll('.game-futur button');
    console.log('Boutons trouv√©s:', buttons.length);
    buttons.forEach(btn => {
      if (btn.id !== 'nextFutur') {
        btn.disabled = true;
      } else {
        btn.disabled = false;
      }
    });
    
    // Mettre √† jour le score
    if (window.updateScoreboard) {
      window.updateScoreboard(game);
    }
  }
  
  // Fonction pour charger les donn√©es du jeu futur depuis le fichier JSON
  function loadFuturData() {
    console.log('D√©but du chargement de futur.json...');
    return fetch('futur.json')
      .then(response => {
        console.log('R√©ponse re√ßue pour futur.json:', response.status, response.statusText);
        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status} ${response.statusText}`);
        }
        return response.json();
      })
      .then(data => {
        if (!data || !data.data || !Array.isArray(data.data)) {
          throw new Error('Format de donn√©es invalide dans futur.json');
        }
        console.log('Donn√©es brutes du futur charg√©es:', data);
        return data.data; // Retourne directement les donn√©es sans transformation
      })
      .catch(error => {
        console.error('Erreur lors du chargement des donn√©es du futur:', error);
      });
  }

  // Fonction pour charger les donn√©es du jeu roles
  async function loadRolesData() {
    console.log('D√©but du chargement de data.json...');
    try {
      const response = await fetch('data.json');
      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status} ${response.statusText}`);
      }
      const data = await response.json();
      console.log('Donn√©es du jeu roles charg√©es avec succ√®s');
      return data;
    } catch (error) {
      console.error('Erreur lors du chargement des donn√©es des r√¥les:', error);
      return [];
    }
  }

  // Fonction pour charger les donn√©es du jeu des temps
  async function loadTempsData() {
    console.log('D√©but du chargement de temps.json...');
    try {
      const response = await fetch('temps.json');
      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status} ${response.statusText}`);
      }
      const data = await response.json();
      console.log('Donn√©es du jeu des temps charg√©es avec succ√®s');
      return data.data || [];
    } catch (error) {
      console.error('Erreur lors du chargement des donn√©es des temps:', error);
      return [];
    }
  }

  // Fonction pour initialiser les jeux
  async function initGames() {
    if (!window.games) {
      // Initialiser la structure des jeux
      window.games = {
        roles: {
          data: [],
          current: 0,
          usedIndices: [],
          r√©ponsesCorrectes: new Set(),
          totalPoints: 0,
          totalErreurs: 0
        },
        futur: {
          data: [],
          current: 0,
          usedIndices: [],
          r√©ponsesCorrectes: new Set(),
          totalPoints: 0,
          totalErreurs: 0
        },
        temps: {
          data: [],
          current: 0,
          usedIndices: [],
          r√©ponsesCorrectes: new Set(),
          totalPoints: 0,
          totalErreurs: 0
        },
        definitions: {
          data: [],
          current: 0,
          usedIndices: [],
          r√©ponsesCorrectes: new Set(),
          totalPoints: 0,
          totalErreurs: 0
        }
      };
      
      // Charger les donn√©es des jeux en parall√®le
      try {
        const [rolesData, futurData, tempsData] = await Promise.all([
          loadRolesData(),
          loadFuturData(),
          loadTempsData()
        ]);
        
        // Mettre √† jour les donn√©es des jeux
        if (rolesData && rolesData.length > 0) {
          window.games.roles.data = rolesData;
          console.log('Donn√©es du jeu roles charg√©es avec succ√®s');
        } else {
          console.warn('Aucune donn√©e charg√©e pour le jeu roles');
        }
        
        if (futurData && futurData.length > 0) {
          window.games.futur.data = futurData;
          console.log('Donn√©es du jeu futur charg√©es avec succ√®s');
        } else {
          console.warn('Aucune donn√©e charg√©e pour le jeu futur');
        }
        
        if (tempsData && tempsData.length > 0) {
          window.games.temps.data = tempsData;
          console.log('Donn√©es du jeu des temps charg√©es avec succ√®s');
        } else {
          console.warn('Aucune donn√©e charg√©e pour le jeu des temps');
        }
        
      } catch (error) {
        console.error('Erreur lors du chargement des donn√©es:', error);
      }
      
      console.log('Jeux initialis√©s avec succ√®s');
    }
  }
  
  // Fonction pour d√©marrer l'application une fois le DOM charg√©
  async function startApp() {
    console.log('D√©marrage de l\'application...');
    
    try {
      // Initialiser les jeux et attendre qu'ils soient pr√™ts
      await initGames();
      
      // V√©rifier que les jeux sont correctement initialis√©s
      if (!window.games) {
        throw new Error('√âchec de l\'initialisation des jeux');
      }
      
      console.log('Jeux initialis√©s avec succ√®s:', Object.keys(window.games));
      console.log('Donn√©es du jeu futur:', window.games?.futur?.data);
      
      // S√©lectionner le jeu par d√©faut (roles)
      selectGame('roles');
      
      // Afficher un message de chargement termin√©
      console.log('Application pr√™te');
      
    } catch (error) {
      console.error('Erreur lors du d√©marrage de l\'application:', error);
      // Afficher un message d'erreur √† l'utilisateur
      const errorDiv = document.createElement('div');
      errorDiv.style.color = 'red';
      errorDiv.style.padding = '20px';
      errorDiv.style.textAlign = 'center';
      errorDiv.textContent = 'Une erreur est survenue lors du chargement de l\'application. Veuillez rafra√Æchir la page.';
      document.body.insertBefore(errorDiv, document.body.firstChild);
    }
  }
  
  // D√©marrer l'application une fois le DOM charg√©
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', startApp);
  } else {
    startApp();
  }
  </script>
</head>
<body>
  <div class="container">
    <button class="menu-btn" onclick="toggleMenu()">‚ò∞</button>
    <nav class="sidebar">
      <div class="logo">
        <h2>R√©vision Grammaire</h2>
      </div>
      <ul class="menu">
        <li class="active">
          <a href="#roles" onclick="selectGame('roles')">
            <span>üîç R√¥les des groupes</span>
          </a>
        </li>
        <li>
          <a href="#futur" onclick="selectGame('futur')">
            <span>üîÆ Futur simple</span>
          </a>
        </li>
        <li>
          <a href="#temps" onclick="selectGame('temps')">
            <span>‚è±Ô∏è Les temps</span>
          </a>
        </li>
        <li>
          <a href="#conjugaison" onclick="selectGame('conjugaison')">
            <span>üìù Conjugaison au futur</span>
          </a>
        </li>
        <li>
          <a href="#geometrie" onclick="selectGame('geometrie')">
            <span>üìê Formes g√©om√©triques</span>
          </a>
        </li>
        <li>
          <a href="#definitions" onclick="selectGame('definitions')">
            <span>üìñ D√©finitions de g√©om√©trie</span>
          </a>
        </li>
      </ul>
    </nav>
  <main class="main-content">
    <div class="top-bar">
      <div id="scoreboard">
        Points : <span id="points">0</span> | Erreurs : <span id="errors">0</span>
        <div class="stars" id="stars"></div>
      </div>
      <button onclick="resetScores()">üîÑ R√©initialiser</button>
    </div>

    <div class="game-content">
      <div class="game-roles">
        <h1>Quel est le r√¥le de chaque groupe ?</h1>
        <div class="phrase" id="phrase">Chargement de la phrase...</div>
        <div>
          <button onclick="checkAnswer('sujet')">üîµ Sujet</button>
          <button onclick="checkAnswer('verbe')">üî¥ Verbe</button>
          <button onclick="checkAnswer('cdv')">üî¥ GCDV</button>
          <button onclick="checkAnswer('civ')">üî¥ GCIV</button>
        </div>
        <p id="feedback"></p>
        <button id="nextBtn" onclick="nextPhrase()" disabled>üëâ Phrase suivante</button>
      </div>
      <div class="game-futur" style="display: none;">
        <h1>Conjugaison au futur simple</h1>
        <div class="futur-content">
          <div class="futur-phrase" id="futur-phrase">Chargement de la phrase...</div>
          <div>
            <button onclick="checkFutur('√™tre')">üîµ √™tre</button>
            <button onclick="checkFutur('avoir')">üî¥ avoir</button>
            <button onclick="checkFutur('er')">üîµ -er</button>
            <button onclick="checkFutur('ir')">üî¥ -ir</button>
          </div>
          <p id="futur-feedback"></p>
          <button id="nextFutur" onclick="nextPhrase('futur')" disabled>üëâ Phrase suivante</button>
        </div>
      </div>
      <div class="game-temps" style="display: none;">
        <h1>Analyse du verbe</h1>
        <div class="temps-content">
          <div class="temps-phrase" id="temps-phrase">Chargement de la phrase...</div>
          
          <div class="input-group">
            <label for="infinitif-input">Infinitif du verbe :</label>
            <input type="text" id="infinitif-input" placeholder="Entrez l'infinitif du verbe">
          </div>
          
          <div class="input-group">
            <label>Temps du verbe :</label>
            <div class="button-group">
              <button onclick="selectAndCheckTemps('pass√©')">‚èÆÔ∏è Pass√©</button>
              <button onclick="selectAndCheckTemps('pr√©sent')">‚èØÔ∏è Pr√©sent</button>
              <button onclick="selectAndCheckTemps('futur')">‚è≠Ô∏è Futur</button>
            </div>
          </div>
          
          <p id="temps-feedback"></p>
          <button id="nextTemps" onclick="nextPhrase('temps')" class="next-btn" disabled>üëâ Phrase suivante</button>
        </div>
      </div>

      <!-- Jeu de g√©om√©trie -->
      <div class="game-geometrie" style="display: none;">
        <h1>Formes g√©om√©triques</h1>
        <div class="geometrie-container">
          <div class="niveau-selection">
            <h2>Choisis un niveau</h2>
            <div class="niveaux-boutons">
              <button class="niveau-btn" data-niveau="polygone-ou-non">Polygone ou non ?</button>
              <button class="niveau-btn" data-niveau="type-polygone">Type de polygone</button>
            </div>
          </div>
          
          <div class="jeu-interface" style="display: none;">
            <div class="niveau-description">
              <h2 id="niveau-titre"></h2>
              <p id="niveau-description"></p>
            </div>
            
            <div id="forme-container">
              <div id="forme-image"></div>
              <div id="forme-options"></div>
              <div class="boutons-actions">
                <button id="btn-valider">Valider</button>
                <button id="btn-suivant" style="display: none;">Suivant</button>
                <button id="recommencer">Recommencer</button>
              </div>
            </div>
            
            <div id="resultats">
              <h3>R√©sultats</h3>
              <p>Score: <span id="score">0</span>/<span id="total">0</span></p>
              <p id="feedback"></p>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Jeu de conjugaison au futur -->
      <div class="game-conjugaison" style="display: none;">
        <h1>Conjugaison au futur</h1>
        <div class="conjugaison-content">
          <div class="conjugaison-header">
            <div class="conjugaison-verbe" id="conjugaison-verbe">Conjuguez le verbe : <span id="verbe-infinitif">chargement...</span></div>
            <div class="verbe-compteur" id="verbe-compteur">1/0</div>
          </div>
          
          <div class="conjugaison-grid">
            <div class="conjugaison-row">
              <label>Je</label>
              <input type="text" id="conj-je" data-personne="je" class="conjugaison-input">
              <span id="result-je" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Tu</label>
              <input type="text" id="conj-tu" data-personne="tu" class="conjugaison-input">
              <span id="result-tu" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Il/Elle/On</label>
              <input type="text" id="conj-il" data-personne="il" class="conjugaison-input">
              <span id="result-il" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Nous</label>
              <input type="text" id="conj-nous" data-personne="nous" class="conjugaison-input">
              <span id="result-nous" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Vous</label>
              <input type="text" id="conj-vous" data-personne="vous" class="conjugaison-input">
              <span id="result-vous" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Ils/Elles</label>
              <input type="text" id="conj-ils" data-personne="ils" class="conjugaison-input">
              <span id="result-ils" class="conjugaison-result"></span>
            </div>
          </div>
          
          <div class="conjugaison-actions">
            <button id="check-conjugaison" class="check-btn">V√©rifier les r√©ponses</button>
            <button id="next-conjugaison" class="next-btn" disabled>Verbe suivant</button>
          </div>
          
          <div id="conjugaison-feedback" class="conjugaison-feedback"></div>
        </div>
      </div>

      <!-- Jeu de g√©om√©trie -->
      <div class="game-geometrie" style="display: none;">
        <h1>D√©couverte des formes g√©om√©triques</h1>
        <p class="niveau-description">S√©lectionne un niveau pour commencer √† jouer !</p>
        
        <div class="geometrie-niveaux">
          <button class="niveau-btn" data-niveau="polygone-ou-non">Niveau 1 : Polygone ou non ?</button>
          <button class="niveau-btn" data-niveau="type-polygone">Niveau 2 : Type de polygone</button>
          <button class="niveau-btn" data-niveau="quadrilateres">Niveau 3 : Les quadrilat√®res</button>
          <button class="niveau-btn" data-niveau="definitions">Apprendre les d√©finitions</button>
        </div>
        
        <div class="forme-container" id="forme-container" style="display: none;">
          <h2 id="niveau-titre"></h2>
          <p id="niveau-description"></p>
          
          <div class="forme-image" id="forme-image">
            <!-- L'image de la forme sera ins√©r√©e ici par JavaScript -->
          </div>
          
          <div class="reponse-boutons" id="reponse-boutons">
            <!-- Les boutons de r√©ponse seront g√©n√©r√©s dynamiquement -->
          </div>
          
          <div class="feedback" id="feedback">
            <p id="feedback-texte"></p>
            <p id="explication"></p>
          </div>
          
          <div class="definition" id="definition" style="display: none;">
            <h3>D√©finition :</h3>
            <p id="definition-texte"></p>
          </div>
          
          <div class="actions">
            <button class="btn btn-primary" id="btn-valider" disabled>Valider</button>
            <button class="btn btn-primary" id="btn-suivant" style="display: none;">Forme suivante</button>
          </div>
        </div>
        
        <div id="resultats" style="text-align: center; margin-top: 20px; display: none;">
          <h3>R√©sultats</h3>
          <p>Score : <span id="score">0</span> / <span id="total">0</span></p>
          <button class="btn btn-primary" id="recommencer">Recommencer</button>
        </div>
      </div>
      
      <!-- D√©but du jeu de d√©finitions -->
      <div id="jeu-definitions" style="display: none;">
        <h2>Associe chaque d√©finition √† la bonne forme</h2>
        <div class="definitions-score">
          Score : <span id="score-definitions">0</span> / <span id="total-definitions">0</span>
        </div>
        <div class="definitions-container">
          <div class="definitions-list" id="definitions-list">
            <!-- Les d√©finitions seront ajout√©es ici dynamiquement -->
          </div>
          <div class="shapes-container" id="shapes-container">
            <!-- Les formes seront ajout√©es ici dynamiquement -->
          </div>
        </div>
        <div class="feedback-def" id="feedback-def"></div>
        <div class="definitions-buttons">
          <button class="btn btn-primary" id="verifier-def">V√©rifier</button>
          <button class="btn btn-primary" id="suivant-def" style="display: none;">D√©finition suivante</button>
        </div>
      </div>
      <!-- Fin du jeu de d√©finitions -->
      
    </div>
    <audio id="sound-bad" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg"></audio>
  </main>

<script>
let currentGame = 'roles'; // Game par d√©faut
let selected = null; // Variable pour stocker le mot s√©lectionn√©

// Variables pour le jeu de conjugaison
let currentVerbe = null;
let verbesData = [];
let currentVerbeIndex = 0;
let games = {
  roles: {
    data: [],
    current: 0,
    usedIndices: [],
    r√©ponsesCorrectes: new Set(),
    totalPoints: 0,
    totalErreurs: 0
  },
  futur: {
    data: [],
    current: 0,
    usedIndices: [],
    r√©ponsesCorrectes: new Set(),
    totalPoints: 0,
    totalErreurs: 0
  }
};

// Charger les donn√©es des r√¥les depuis le fichier JSON
fetch('./data.json')
  .then(response => response.json())
  .then(rolesData => {
    if (rolesData && Array.isArray(rolesData) && rolesData.length > 0) {
      games.roles.data = rolesData;
      selectGame('roles'); // Charger le jeu par d√©faut apr√®s le chargement des donn√©es
    } else {
      console.error('Donn√©es des r√¥les invalides ou manquantes');
      document.getElementById('phrase').textContent = 'Erreur : Donn√©es des r√¥les manquantes.';
    }
  })
  .catch(err => {
    console.error('Erreur de chargement des donn√©es des r√¥les:', err);
    document.getElementById('phrase').textContent = 'Erreur : Impossible de charger les donn√©es des r√¥les.';
  });

// Charger les donn√©es du futur depuis le fichier JSON
fetch('futur.json')
  .then(response => {
    if (!response.ok) {
      throw new Error(`Erreur HTTP: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    if (data && data.data && Array.isArray(data.data)) {
      games.futur.data = data.data;
      console.log('Donn√©es du futur charg√©es avec succ√®s:', games.futur.data);
    } else {
      throw new Error('Format de donn√©es invalide dans futur.json');
    }
  })
  .catch(error => {
    console.error('Erreur lors du chargement du fichier futur.json:', error);
  });

// Ajouter les gestionnaires d'√©v√©nements pour les boutons du futur
document.addEventListener('DOMContentLoaded', function() {
  // Charger les donn√©es du jeu de d√©finitions
  fetch('definitions.json')
    .then(response => {
      if (!response.ok) {
        throw new Error('Erreur de chargement des d√©finitions');
      }
      return response.json();
    })
    .then(data => {
      window.definitionsData = data.definitions;
      console.log('Donn√©es des d√©finitions charg√©es:', window.definitionsData);
    })
    .catch(error => {
      console.error('Erreur lors du chargement des d√©finitions:', error);
      document.getElementById('jeu-definitions').innerHTML = 
        '<p class="error">Erreur de chargement des d√©finitions. Veuillez recharger la page.</p>';
    });
    
  console.log('Ajout des gestionnaires d\'√©v√©nements pour les boutons du futur');
  
  // Gestionnaire pour le bouton √™tre
  const btnEtre = document.querySelector('button[onclick*="checkFutur(\'√™tre\')"]');
  if (btnEtre) {
    console.log('Bouton √™tre trouv√©');
    btnEtre.onclick = function() { checkFutur('√™tre'); };
  }
  
  // Gestionnaire pour le bouton avoir
  const btnAvoir = document.querySelector('button[onclick*="checkFutur(\'avoir\')"]');
  if (btnAvoir) {
    console.log('Bouton avoir trouv√©');
    btnAvoir.onclick = function() { checkFutur('avoir'); };
  }
  
  // Gestionnaire pour le bouton -er
  const btnEr = document.querySelector('button[onclick*="checkFutur(\'er\')"]');
  if (btnEr) {
    console.log('Bouton -er trouv√©');
    btnEr.onclick = function() { checkFutur('er'); };
  }
  
  // Gestionnaire pour le bouton -ir
  const btnIr = document.querySelector('button[onclick*="checkFutur(\'ir\')"]');
  if (btnIr) {
    console.log('Bouton -ir trouv√©');
    btnIr.onclick = function() { checkFutur('ir'); };
  }
  
  // Gestionnaire pour le bouton V√©rifier du jeu de d√©finitions
  const btnVerifierDef = document.getElementById('verifier-def');
  if (btnVerifierDef) {
    btnVerifierDef.addEventListener('click', verifierReponseDefinition);
  }
  
  // Gestionnaire pour le bouton Suivant du jeu de d√©finitions
  const btnSuivantDef = document.getElementById('suivant-def');
  if (btnSuivantDef) {
    btnSuivantDef.addEventListener('click', afficherDefinitionSuivante);
  }
});

// Le chargement du jeu par d√©faut est maintenant g√©r√© dans startApp()

function selectGame(game) {
  console.log('S√©lection du jeu:', game);
  
  // Fermer le menu sur mobile/tablette
  if (window.innerWidth <= 1024) {
    const sidebar = document.querySelector('.sidebar');
    if (sidebar) {
      sidebar.classList.remove('active');
    }
  }
  
  // Masquer tous les jeux
  document.querySelectorAll('.game-content > div, #jeu-definitions').forEach(el => {
    el.style.display = 'none';
  });
  
  // R√©initialiser le jeu actuel
  resetGame(game);
  
  // Afficher le jeu s√©lectionn√©
  if (game === 'futur') {
    document.querySelector('.game-futur').style.display = 'block';
    currentGame = 'futur';
    nextPhrase('futur');
  } else if (game === 'roles') {
    document.querySelector('.game-roles').style.display = 'block';
    currentGame = 'roles';
    nextPhrase('roles');
  } else if (game === 'temps') {
    document.querySelector('.game-temps').style.display = 'block';
    currentGame = 'temps';
    nextPhrase('temps');
  } else if (game === 'conjugaison') {
    document.querySelector('.game-conjugaison').style.display = 'block';
    currentGame = 'conjugaison';
    initConjugaison();
  } else if (game === 'geometrie') {
    document.querySelector('.game-geometrie').style.display = 'block';
    currentGame = 'geometrie';
    initialiserJeuGeometrie();
  } else if (game === 'definitions') {
    const definitionsGame = document.getElementById('jeu-definitions');
    if (definitionsGame) {
      definitionsGame.style.display = 'block';
      currentGame = 'definitions';
      initialiserJeuDefinitions();
    } else {
      console.error('√âl√©ment du jeu de d√©finitions non trouv√©');
    }
  }
  
  // Mettre √† jour le menu
  document.querySelectorAll('.sidebar a').forEach(link => {
    link.classList.remove('active');
  });
  document.querySelector(`.sidebar a[onclick*="${game}"]`).classList.add('active');
  
  // Fermer le menu mobile si ouvert
  document.querySelector('.sidebar').classList.remove('active');
}

function resetGame(game = currentGame) {
  console.log(`R√©initialisation du jeu: ${game}`);
  
  const gameData = window.games?.[game];
  if (!gameData) {
    console.error('Impossible de r√©initialiser: jeu non trouv√©:', game);
    return;
  }
  
  // R√©initialiser les scores et l'√©tat
  gameData.totalPoints = 0;
  gameData.totalErreurs = 0;
  gameData.usedIndices = [];
  
  // Pour le jeu des r√¥les, r√©initialiser les r√©ponses correctes
  if (game === 'roles') {
    gameData.r√©ponsesCorrectes = new Set();
  }
  
  // S'assurer que current est d√©fini
  gameData.current = 0;
  
  console.log('Donn√©es du jeu apr√®s r√©initialisation:', gameData);
  
  // Ne pas appeler nextPhrase pour le jeu de d√©finitions car il utilise sa propre logique
  if (game !== 'definitions') {
    // Choisir une phrase al√©atoire pour les autres jeux
    nextPhrase(game);
  }
  
  // Mettre √† jour le score
  updateScoreboard(game);
  
  // R√©initialiser l'affichage
  if (game === 'futur') {
    const feedback = document.getElementById('futur-feedback');
    if (feedback) {
      feedback.textContent = '';
      feedback.style.color = '';
    }
  } else {
    const feedback = document.getElementById('feedback');
    if (feedback) {
      feedback.textContent = '';
    }
  }
  document.getElementById('nextBtn').disabled = true;
}

function updateScoreboard(game = currentGame) {
  if (!window.games || !window.games[game]) {
    console.error('Donn√©es du jeu non disponibles pour la mise √† jour du score');
    return;
  }
  
  const gameData = window.games[game];
  const pointsElement = document.getElementById('points');
  const errorsElement = document.getElementById('errors');
  const starsElement = document.getElementById('stars');
  
  if (pointsElement) pointsElement.textContent = gameData.totalPoints;
  if (errorsElement) errorsElement.textContent = gameData.totalErreurs;
  
  // Ajouter une √©toile par tranche de 10 points
  const starCount = Math.floor(Math.max(0, gameData.totalPoints) / 10);
  if (starsElement) {
    starsElement.textContent = '‚≠ê'.repeat(starCount);
    console.log(`Mise √† jour du score: ${gameData.totalPoints} points, ${starCount} √©toiles`);
  }
}

function renderPhrase(game = currentGame) {
  console.log(`Rendu de la phrase pour le jeu: ${game}`);
  
  if (!window.games) {
    console.error('Jeux non initialis√©s');
    return;
  }
  
  const gameData = window.games[game];
  if (!gameData) {
    console.error('Donn√©es du jeu non trouv√©es pour:', game, 'Disponibles:', Object.keys(window.games));
    return;
  }
  
  if (!gameData.data || !Array.isArray(gameData.data) || gameData.data.length === 0) {
    console.error('Aucune donn√©e de phrase disponible pour le jeu:', game);
    return;
  }
  
  if (typeof gameData.current === 'undefined' || !gameData.data[gameData.current]) {
    console.error('Index de phrase invalide:', gameData.current, 'pour le jeu:', game);
    return;
  }
  
  const phraseObj = gameData.data[gameData.current];
  console.log('Phrase actuelle:', phraseObj);
  
  // G√©rer le jeu des r√¥les
  if (game === 'roles') {
    const phraseTexte = phraseObj.phrase;
    let html = phraseTexte;
    document.getElementById('feedback').textContent = '';
    document.getElementById('nextBtn').disabled = true;
    gameData.r√©ponsesCorrectes = new Set();
    selected = null;

    // Remplace chaque groupe par un <span>
    if (phraseObj.groupes && Array.isArray(phraseObj.groupes)) {
      phraseObj.groupes.forEach((g, index) => {
        const escaped = g.texte.replace(/[.*+?^${}()|\\]/g, '\\$&');
        const pattern = new RegExp(escaped, 'i'); // ignore la casse
        html = html.replace(
          pattern,
          `<span class="mot" data-role="${g.role}" data-index="${index}">${g.texte}</span>`
        );
      });
    }

    const container = document.getElementById('phrase');
    container.innerHTML = html;

    container.querySelectorAll('.mot').forEach(span => {
      span.onclick = () => {
        if (span.classList.contains('bleu') || span.classList.contains('rouge')) return;
        document.querySelectorAll('.mot').forEach(m => m.classList.remove('selected'));
        selected = span;
        span.classList.add('selected');
        document.getElementById('feedback').textContent = '';
      };
    });
  }
  // G√©rer le jeu du futur simple
  else if (game === 'futur') {
    const container = document.getElementById('futur-phrase');
    if (!container) {
      console.error('√âl√©ment futur-phrase non trouv√©');
      return;
    }
    container.textContent = phraseObj.phrase || 'Phrase non disponible';
    
    const feedbackElement = document.getElementById('futur-feedback');
    if (feedbackElement) {
      feedbackElement.textContent = '';
      feedbackElement.style.color = '';
    }
    document.getElementById('nextFutur').disabled = true;
  }
  // G√©rer le jeu des temps
  else if (game === 'temps') {
    const container = document.getElementById('temps-phrase');
    if (!container) {
      console.error('√âl√©ment temps-phrase non trouv√©');
      return;
    }
    container.textContent = phraseObj.phrase || 'Phrase non disponible';
    
    const feedbackElement = document.getElementById('temps-feedback');
    if (feedbackElement) {
      feedbackElement.textContent = '';
      feedbackElement.style.color = '';
    }
    
    // R√©activer le champ de saisie et les boutons de r√©ponse
    const infinitifInput = document.getElementById('infinitif-input');
    if (infinitifInput) {
      infinitifInput.disabled = false;
      infinitifInput.value = ''; // R√©initialiser la valeur
    }
    
    // R√©activer les boutons de temps
    document.querySelectorAll('.game-temps .button-group button').forEach(btn => {
      btn.disabled = false;
    });
    
    // D√©s√©lectionner le temps pr√©c√©dent
    selectedTemps = null;
    
    // Les boutons de temps sont d√©j√† d√©sactiv√©s par d√©faut
    
    const nextBtn = document.getElementById('nextTemps');
    if (nextBtn) nextBtn.disabled = true;
  }
}

// La fonction checkFutur est maintenant d√©finie dans le <head> pour √™tre disponible imm√©diatement

function checkAnswer(answer, game = currentGame) {
  if (!selected) {
    alert("Clique sur un groupe de mots.");
    return;
  }

  const gameData = games[game];
  const role = selected.dataset.role;
  const idx = selected.dataset.index;
  selected.classList.remove('selected');

  if (answer === role) {
    selected.classList.add('bleu');
    document.getElementById('feedback').textContent = '‚úÖ Bonne r√©ponse !';
    gameData.r√©ponsesCorrectes.add(idx);
    gameData.totalPoints++;
  } else {
    selected.classList.add('rouge');
    document.getElementById('feedback').textContent = ' Mauvaise r√©ponse !';
    gameData.totalErreurs++;
    const sound = document.getElementById('sound-bad');
    sound.currentTime = 0;
    sound.play();
  }

  updateScoreboard(game);

  if (gameData.r√©ponsesCorrectes.size === gameData.data[gameData.current].groupes.length) {
    document.getElementById('nextBtn').disabled = false;
  }
}



function nextPhrase(game = currentGame) {
  if (!window.games) {
    console.error('Jeux non initialis√©s');
    return;
  }
  
  const gameData = window.games[game];
  if (!gameData) {
    console.error('Jeu non trouv√©:', game, 'Disponibles:', Object.keys(window.games));
    return;
  }
  
  console.log('Passage √† la phrase suivante. Indices utilis√©s:', gameData.usedIndices);
  
  // R√©activer les boutons de r√©ponse
  document.querySelectorAll('.game-futur button:not(#nextFutur)').forEach(btn => {
    btn.disabled = false;
  });
  
  // Si toutes les phrases ont √©t√© utilis√©es, r√©initialiser
  if (gameData.usedIndices.length >= gameData.data.length) {
    console.log('Toutes les phrases ont √©t√© utilis√©es, r√©initialisation...');
    gameData.usedIndices = [];
  }
  
  // Choisir une nouvelle phrase al√©atoire qui n'a pas encore √©t√© utilis√©e
  let newIndex;
  do {
    newIndex = Math.floor(Math.random() * gameData.data.length);
  } while (gameData.usedIndices.includes(newIndex) && gameData.usedIndices.length < gameData.data.length);
  
  console.log('Nouvel index choisi:', newIndex, 'sur', gameData.data.length - 1);
  
  // Mettre √† jour l'index actuel et l'ajouter aux indices utilis√©s
  gameData.current = newIndex;
  gameData.usedIndices.push(newIndex);
  
  console.log('Nouvelle phrase charg√©e:', gameData.data[gameData.current]);
  console.log('Index actuel apr√®s mise √† jour:', gameData.current);
  
  // Afficher la nouvelle phrase
  console.log('Appel de renderPhrase avec game:', game);
  renderPhrase(game);
  
  // D√©sactiver le bouton suivant jusqu'√† ce qu'une r√©ponse soit donn√©e
  if (game === 'futur') {
    const nextBtn = document.getElementById('nextFutur');
    if (nextBtn) nextBtn.disabled = true;
  } else {
    const nextBtn = document.getElementById('nextBtn');
    if (nextBtn) nextBtn.disabled = true;
  }
}

// Variables pour stocker la s√©lection de l'utilisateur
let selectedTemps = null;

// Fonction pour s√©lectionner un temps
function selectTemps(temps) {
  selectedTemps = temps;
  
  // Mettre √† jour le style des boutons
  document.querySelectorAll('.game-temps .button-group button').forEach(btn => {
    if (btn.textContent.includes(temps)) {
      btn.style.backgroundColor = '#4CAF50';
      btn.style.color = 'white';
    } else {
      btn.style.backgroundColor = '';
      btn.style.color = '';
    }
  });
  
  return document.getElementById('infinitif-input') && document.getElementById('infinitif-input').value.trim() !== '';
}

// Fonction pour s√©lectionner un temps et valider imm√©diatement
function selectAndCheckTemps(temps) {
  const isInfinitifValid = selectTemps(temps);
  
  if (!isInfinitifValid) {
    alert('Veuillez d\'abord entrer l\'infinitif du verbe');
    return;
  }
  
  checkTemps();
}

// Fonction pour v√©rifier la r√©ponse dans le jeu des temps
function checkTemps() {
  const game = 'temps';
  const infinitifInput = document.getElementById('infinitif-input');
  const userInfinitif = infinitifInput ? infinitifInput.value.trim().toLowerCase() : '';
  
  if (!selectedTemps) {
    alert('Veuillez s√©lectionner un temps');
    return;
  }
  
  if (!userInfinitif) {
    alert('Veuillez entrer l\'infinitif du verbe');
    return;
  }
  console.log('=== FONCTION checkTemps APPEL√âE ===');
  console.log('Temps choisi:', selectedTemps);
  
  if (!window.games) {
    console.error('L\'objet games n\'est pas encore charg√©');
    return;
  }
  
  // D√©sactiver les champs de saisie et les boutons
  if (infinitifInput) infinitifInput.disabled = true;
  document.querySelectorAll('.game-temps .button-group button').forEach(btn => {
    btn.disabled = true;
  });
  
  const gameData = window.games[game];
  if (!gameData) {
    console.error('Jeu non trouv√©:', game, 'Disponibles:', Object.keys(window.games));
    return;
  }
  
  const currentData = gameData.data[gameData.current];
  if (!currentData) {
    console.error('Aucune donn√©e pour la phrase actuelle');
    return;
  }
  
  const feedbackElement = document.getElementById('temps-feedback');
  const expectedAnswer = currentData.temps;
  const expectedInfinitif = currentData.infinitif.toLowerCase();
  
  console.log('R√©ponse attendue:', {
    temps: expectedAnswer,
    infinitif: expectedInfinitif
  }, 'R√©ponse donn√©e:', {
    temps: selectedTemps,
    infinitif: userInfinitif
  });
  
  const tempsCorrect = selectedTemps === expectedAnswer;
  const infinitifCorrect = userInfinitif === expectedInfinitif;
  
  if (tempsCorrect && infinitifCorrect) {
    console.log('Bonne r√©ponse pour le temps et l\'infinitif');
    feedbackElement.innerHTML = `‚úÖ Parfait ! ${expectedInfinitif} est bien au ${expectedAnswer}.<br>+1 point`;
    feedbackElement.style.color = 'green';
    gameData.totalPoints++;
  } else if (tempsCorrect && !infinitifCorrect) {
    console.log('Mauvaise r√©ponse pour l\'infinitif');
    feedbackElement.innerHTML = `‚ùå L'infinitif √©tait ${expectedInfinitif} (le temps √©tait correct).<br>-1 point`;
    feedbackElement.style.color = 'red';
    if (gameData.totalPoints > 0) gameData.totalPoints--;
    gameData.totalErreurs++;
  } else if (!tempsCorrect && infinitifCorrect) {
    console.log('Mauvaise r√©ponse pour le temps');
    feedbackElement.innerHTML = `‚ùå Le temps √©tait ${expectedAnswer} (l'infinitif √©tait correct).<br>-1 point`;
    feedbackElement.style.color = 'red';
    if (gameData.totalPoints > 0) gameData.totalPoints--;
    gameData.totalErreurs++;
  } else {
    console.log('Mauvaise r√©ponse pour le temps et l\'infinitif');
    feedbackElement.innerHTML = `‚ùå L'infinitif √©tait ${expectedInfinitif} et le temps √©tait ${expectedAnswer}.<br>-1 point`;
    feedbackElement.style.color = 'red';
    if (gameData.totalPoints > 0) gameData.totalPoints--;
    gameData.totalErreurs++;
    
    // Jouer un son d'erreur
    const errorSound = document.getElementById('error-sound');
    if (errorSound) {
      errorSound.play().catch(e => console.error('Erreur de lecture du son:', e));
    }
  }
  
  // Mettre √† jour le tableau des scores
  updateScoreboard(game);
  
  // D√©sactiver les boutons de r√©ponse et activer le bouton suivant
  document.querySelectorAll('.game-temps button:not(#nextTemps)').forEach(btn => {
    btn.disabled = true;
  });
  
  const nextBtn = document.getElementById('nextTemps');
  if (nextBtn) nextBtn.disabled = false;
}

// Fonction pour g√©rer le changement de jeu
function selectGame(game) {
  // Fermer le menu sur mobile/tablette
  if (window.innerWidth <= 1024) {
    const sidebar = document.querySelector('.sidebar');
    if (sidebar) {
      sidebar.classList.remove('active');
    }
  }

  // Mettre √† jour le menu
  document.querySelectorAll('.menu li').forEach(li => {
    li.classList.remove('active');
    if (li.children[0].href.includes(`#${game}`)) {
      li.classList.add('active');
    }
  });

  // Cacher tous les jeux
  document.querySelectorAll('.game-content > div').forEach(div => {
    div.style.display = 'none';
  });

  // Afficher le jeu s√©lectionn√©
  const gameDiv = document.querySelector(`.game-${game}`);
  if (gameDiv) {
    gameDiv.style.display = 'block';
  } else {
    console.error('√âl√©ment du jeu non trouv√©:', `.game-${game}`);
  }

  // R√©initialiser les scores
  resetGame(game);
}

// Fonction pour g√©rer le menu hamburger
function toggleMenu() {
  const sidebar = document.querySelector('.sidebar');
  const menuBtn = document.querySelector('.menu-btn');
  
  if (sidebar.style.left === '0px' || !sidebar.style.left) {
    sidebar.style.left = '-250px';
    menuBtn.textContent = '‚ò∞';
    menuBtn.style.left = '10px';
  } else {
    sidebar.style.left = '0';
    menuBtn.textContent = '‚úï';
    menuBtn.style.left = '260px';
  }
}

// Fonction utilitaire pour m√©langer un tableau
function melangerTableau(array) {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
}

// Alias pour la compatibilit√© avec le code existant
const shuffleArray = melangerTableau;

// Afficher le prochain verbe √† conjuguer
function nextVerbe() {
  if (!verbesData || verbesData.length === 0) {
    const element = document.getElementById('conjugaison-verbe');
    if (element) element.textContent = 'Tous les verbes ont √©t√© utilis√©s !';
    const checkBtn = document.getElementById('check-conjugaison');
    if (checkBtn) checkBtn.disabled = true;
    return;
  }
  
  // Prendre le premier verbe de la liste
  currentVerbe = verbesData.shift();
  const verbeElement = document.getElementById('verbe-infinitif');
  if (verbeElement) verbeElement.textContent = currentVerbe.infinitif;
  
  // R√©initialiser les champs
  document.querySelectorAll('.conjugaison-input').forEach(input => {
    input.value = '';
    input.disabled = false;
    input.classList.remove('correct', 'incorrect');
  });
  
  // R√©initialiser les r√©sultats
  document.querySelectorAll('.conjugaison-result').forEach(span => {
    span.textContent = '';
  });
  
  // R√©initialiser le feedback
  const feedback = document.getElementById('conjugaison-feedback');
  if (feedback) feedback.textContent = '';
  
  // D√©sactiver le bouton suivant
  const nextBtn = document.getElementById('next-conjugaison');
  if (nextBtn) nextBtn.disabled = true;
  
  // Activer le bouton de v√©rification
  const checkBtn = document.getElementById('check-conjugaison');
  if (checkBtn) checkBtn.disabled = false;
}

// V√©rifier les r√©ponses
function checkConjugaison() {
  if (!currentVerbe) return;
  
  let score = 0;
  const personnes = ['je', 'tu', 'il', 'nous', 'vous', 'ils'];
  
  personnes.forEach(personne => {
    const input = document.getElementById(`conj-${personne}`);
    const resultSpan = document.getElementById(`result-${personne}`);
    if (!input || !resultSpan) return;
    
    const reponse = input.value.trim().toLowerCase();
    const bonneReponse = currentVerbe.conjugaisons[personne];
    
    if (reponse === bonneReponse) {
      input.classList.add('correct');
      input.classList.remove('incorrect');
      resultSpan.textContent = '‚úì';
      resultSpan.className = 'conjugaison-result correct';
      score++;
    } else {
      input.classList.add('incorrect');
      input.classList.remove('correct');
      resultSpan.textContent = bonneReponse;
      resultSpan.className = 'conjugaison-result incorrect';
    }
    
    // D√©sactiver le champ apr√®s v√©rification
    input.disabled = true;
  });
  
  // Afficher le score
  const scoreText = `Score : ${score}/6`;
  const feedback = document.getElementById('conjugaison-feedback');
  if (feedback) {
    feedback.textContent = score === 6 
      ? `‚úÖ Parfait ! ${scoreText}` 
      : `‚ùå ${scoreText} - Essayez encore ou passez au verbe suivant`;
  }
  
  // Activer le bouton suivant
  const nextBtn = document.getElementById('next-conjugaison');
  if (nextBtn) nextBtn.disabled = false;
  
  // D√©sactiver le bouton de v√©rification
  const checkBtn = document.getElementById('check-conjugaison');
  if (checkBtn) checkBtn.disabled = true;
}

// Variables globales pour le jeu de conjugaison
let scoreConjugaison = 0;
let totalVerbes = 0;

// Variables globales pour le jeu de g√©om√©trie
let scoreGeometrie = 0;
let totalGeometrie = 0;
let formeActuelle = null;
let niveauActuel = null;
let formes = [];
let formesRestantes = [];
let geometrieData = {};

// Donn√©es pour le jeu de d√©finitions
const definitionsData = [
  {
    id: 'polygone',
    terme: 'Polygone',
    definition: 'Une surface dont tous les c√¥t√©s sont droits',
    image: 'images/geometrie/pentagone.svg',
    reponses: [
      'Une surface dont tous les c√¥t√©s sont droits',
      'Un polygone √† 4 c√¥t√©s',
      'Une figure avec des courbes'
    ]
  },
  {
    id: 'quadrilatere',
    terme: 'Quadrilat√®re',
    definition: 'Un polygone √† 4 c√¥t√©s',
    image: 'images/geometrie/rectangle.svg',
    reponses: [
      'Un polygone √† 4 c√¥t√©s',
      'Un polygone √† 3 c√¥t√©s',
      'Un polygone √† 5 c√¥t√©s'
    ]
  },
  {
    id: 'triangle',
    terme: 'Triangle',
    definition: 'Un polygone √† 3 c√¥t√©s',
    image: 'images/geometrie/triangle.svg',
    reponses: [
      'Un polygone √† 3 c√¥t√©s',
      'Un polygone √† 4 c√¥t√©s',
      'Un polygone √† 5 c√¥t√©s'
    ]
  },
  {
    id: 'pentagone',
    terme: 'Pentagone',
    definition: 'Un polygone √† 5 c√¥t√©s',
    image: 'images/geometrie/pentagone.svg',
    reponses: [
      'Un polygone √† 5 c√¥t√©s',
      'Un polygone √† 4 c√¥t√©s',
      'Un polygone √† 6 c√¥t√©s'
    ]
  },
  {
    id: 'hexagone',
    terme: 'Hexagone',
    definition: 'Un polygone √† 6 c√¥t√©s',
    image: 'images/geometrie/hexagone.svg',
    reponses: [
      'Un polygone √† 6 c√¥t√©s',
      'Un polygone √† 5 c√¥t√©s',
      'Un polygone √† 4 c√¥t√©s'
    ]
  },
  {
    id: 'octogone',
    terme: 'Octogone',
    definition: 'Un polygone √† 8 c√¥t√©s',
    image: 'images/geometrie/octogone.svg',
    reponses: [
      'Un polygone √† 8 c√¥t√©s',
      'Un polygone √† 6 c√¥t√©s',
      'Un polygone √† 10 c√¥t√©s'
    ]
  },
  {
    id: 'cercle',
    terme: 'Cercle',
    definition: 'Une figure plane dont tous les points sont √† √©gale distance d\'un point central appel√© centre',
    image: 'images/geometrie/cercle.svg',
    reponses: [
      'Une figure plane dont tous les points sont √† √©gale distance d\'un point central appel√© centre',
      'Un polygone √† 4 c√¥t√©s √©gaux',
      'Un polygone √† 3 c√¥t√©s'
    ]
  },
  {
    id: 'carre',
    terme: 'Carr√©',
    definition: 'Un quadrilat√®re qui a 4 c√¥t√©s isom√©triques et 4 angles droits',
    image: 'images/geometrie/carre.svg',
    reponses: [
      'Un quadrilat√®re qui a 4 c√¥t√©s isom√©triques et 4 angles droits',
      'Un quadrilat√®re avec 2 paires de c√¥t√©s parall√®les',
      'Un polygone √† 6 c√¥t√©s'
    ]
  },
  {
    id: 'rectangle',
    terme: 'Rectangle',
    definition: 'Un quadrilat√®re qui a 4 angles droits et des c√¥t√©s oppos√©s de m√™me longueur',
    image: 'images/geometrie/rectangle.svg',
    reponses: [
      'Un quadrilat√®re qui a 4 angles droits et des c√¥t√©s oppos√©s de m√™me longueur',
      'Un quadrilat√®re avec 4 c√¥t√©s √©gaux',
      'Un polygone √† 3 c√¥t√©s'
    ]
  },
  {
    id: 'losange',
    terme: 'Losange',
    definition: 'Un quadrilat√®re qui a 4 c√¥t√©s de m√™me longueur et des c√¥t√©s oppos√©s parall√®les',
    image: 'images/geometrie/losange.svg',
    reponses: [
      'Un quadrilat√®re qui a 4 c√¥t√©s de m√™me longueur et des c√¥t√©s oppos√©s parall√®les',
      'Un quadrilat√®re avec 4 angles droits',
      'Un polygone √† 5 c√¥t√©s'
    ]
  },
  {
    id: 'parallelogramme',
    terme: 'Parall√©logramme',
    definition: 'Un quadrilat√®re dont les c√¥t√©s oppos√©s sont parall√®les et de m√™me longueur',
    image: 'images/geometrie/parallelogramme.svg',
    reponses: [
      'Un quadrilat√®re dont les c√¥t√©s oppos√©s sont parall√®les et de m√™me longueur',
      'Un quadrilat√®re avec 4 angles droits',
      'Un polygone √† 5 c√¥t√©s √©gaux'
    ]
  },
  {
    id: 'trapeze',
    terme: 'Trap√®ze',
    definition: 'Un quadrilat√®re qui a au moins une paire de c√¥t√©s parall√®les',
    image: 'images/geometrie/trapeze.svg',
    reponses: [
      'Un quadrilat√®re qui a au moins une paire de c√¥t√©s parall√®les',
      'Un quadrilat√®re avec 4 c√¥t√©s √©gaux',
      'Un polygone √† 3 c√¥t√©s'
    ]
  },
  {
    id: 'triangle-equilateral',
    terme: 'Triangle √©quilat√©ral',
    definition: 'Un triangle qui a ses trois c√¥t√©s de m√™me longueur',
    image: 'images/geometrie/triangle-equilateral.svg',
    reponses: [
      'Un triangle qui a ses trois c√¥t√©s de m√™me longueur',
      'Un triangle avec deux c√¥t√©s √©gaux',
      'Un triangle avec un angle droit'
    ]
  },
  {
    id: 'triangle-isocele',
    terme: 'Triangle isoc√®le',
    definition: 'Un triangle qui a deux c√¥t√©s de m√™me longueur',
    image: 'images/geometrie/triangle-isocele.svg',
    reponses: [
      'Un triangle qui a deux c√¥t√©s de m√™me longueur',
      'Un triangle avec trois c√¥t√©s √©gaux',
      'Un triangle avec un angle obtus'
    ]
  },
  {
    id: 'triangle-rectangle',
    terme: 'Triangle rectangle',
    definition: 'Un triangle qui a un angle droit',
    image: 'images/geometrie/triangle-rectangle.svg',
    reponses: [
      'Un triangle qui a un angle droit',
      'Un triangle avec trois c√¥t√©s √©gaux',
      'Un triangle avec un angle obtus'
    ]
  },
  {
    id: 'triangle-quelconque',
    terme: 'Triangle quelconque',
    definition: 'Un triangle qui n\'a pas de propri√©t√©s particuli√®res',
    image: 'images/geometrie/triangle-quelconque.svg',
    reponses: [
      'Un triangle qui n\'a pas de propri√©t√©s particuli√®res',
      'Un triangle avec trois c√¥t√©s √©gaux',
      'Un triangle avec un angle droit'
    ]
  },
  {
    id: 'disque',
    terme: 'Disque',
    definition: 'La surface d√©limit√©e par un cercle',
    image: 'images/geometrie/disque.svg',
    reponses: [
      'La surface d√©limit√©e par un cercle',
      'La ligne qui forme un cercle',
      'Un demi-cercle'
    ]
  },
  {
    id: 'ovale',
    terme: 'Ovale',
    definition: 'Une forme arrondie allong√©e qui ressemble √† un ≈ìuf',
    image: 'images/geometrie/ovale.svg',
    reponses: [
      'Une forme arrondie allong√©e qui ressemble √† un ≈ìuf',
      'Un cercle parfait',
      'Un demi-cercle'
    ]
  },
  {
    id: 'demi-cercle',
    terme: 'Demi-cercle',
    definition: 'La moiti√© d\'un cercle, d√©limit√©e par un diam√®tre et un demi-p√©rim√®tre',
    image: 'images/geometrie/demi-cercle.svg',
    reponses: [
      'La moiti√© d\'un cercle, d√©limit√©e par un diam√®tre et un demi-p√©rim√®tre',
      'Un cercle complet',
      'Un quart de cercle'
    ]
  },
  {
    id: 'secteur-circulaire',
    terme: 'Secteur circulaire',
    definition: 'Une portion de disque d√©limit√©e par deux rayons et un arc de cercle',
    image: 'images/geometrie/secteur-circulaire.svg',
    reponses: [
      'Une portion de disque d√©limit√©e par deux rayons et un arc de cercle',
      'La moiti√© d\'un cercle',
      'Un quart de cercle'
    ]
  },
  {
    id: 'segment-circulaire',
    terme: 'Segment circulaire',
    definition: 'La portion de disque comprise entre un arc de cercle et la corde qui le sous-tend',
    image: 'images/geometrie/segment-circulaire.svg',
    reponses: [
      'La portion de disque comprise entre un arc de cercle et la corde qui le sous-tend',
      'La moiti√© d\'un cercle',
      'Un secteur angulaire'
    ]
  },
  {
    id: 'couronne-circulaire',
    terme: 'Couronne circulaire',
    definition: 'La surface comprise entre deux cercles concentriques',
    image: 'images/geometrie/couronne-circulaire.svg',
    reponses: [
      'La surface comprise entre deux cercles concentriques',
      'Un demi-cercle',
      'Un secteur angulaire'
    ]
  },
  {
    id: 'ellipse',
    terme: 'Ellipse',
    definition: 'Une courbe plane ferm√©e qui ressemble √† un cercle allong√©',
    image: 'images/geometrie/ellipse.svg',
    reponses: [
      'Une courbe plane ferm√©e qui ressemble √† un cercle allong√©',
      'Un cercle parfait',
      'Une parabole'
    ]
  },
  {
    id: 'parabole',
    terme: 'Parabole',
    definition: 'Une courbe plane sym√©trique dont chaque point est √† √©gale distance d\'un point fixe (foyer) et d\'une droite fixe (directrice)',
    image: 'images/geometrie/parabole.svg',
    reponses: [
      'Une courbe plane sym√©trique dont chaque point est √† √©gale distance d\'un point fixe et d\'une droite fixe',
      'Un cercle',
      'Une ellipse'
    ]
  },
  {
    id: 'hyperbole',
    terme: 'Hyperbole',
    definition: 'Une courbe plane ouverte √† deux branches, obtenue par l\'intersection d\'un c√¥ne avec un plan parall√®le √† son axe',
    image: 'images/geometrie/hyperbole.svg',
    reponses: [
      'Une courbe plane ouverte √† deux branches, obtenue par l\'intersection d\'un c√¥ne avec un plan parall√®le √† son axe',
      'Une parabole',
      'Une ellipse'
    ]
  },
  {
    id: 'spirale',
    terme: 'Spirale',
    definition: 'Une courbe plane qui tourne autour d\'un point central en s\'en √©loignant de plus en plus',
    image: 'images/geometrie/spirale.svg',
    reponses: [
      'Une courbe plane qui tourne autour d\'un point central en s\'en √©loignant de plus en plus',
      'Un cercle',
      'Une parabole'
    ]
  },
  {
    id: 'parallelogramme',
    terme: 'Parall√©logramme',
    definition: 'Un quadrilat√®re qui a 2 paires de c√¥t√©s parall√®les',
    image: 'images/geometrie/parallelogramme.svg',
    reponses: [
      'Un quadrilat√®re qui a 1 paire de c√¥t√©s parall√®les',
      'Un quadrilat√®re qui a 2 paires de c√¥t√©s parall√®les',
      'Un quadrilat√®re avec 4 angles droits'
    ]
  },
  {
    id: 'trapeze',
    terme: 'Trap√®ze',
    definition: 'Un quadrilat√®re qui a 1 paire de c√¥t√©s parall√®les',
    image: 'images/geometrie/trapeze.svg',
    reponses: [
      'Un quadrilat√®re avec 4 c√¥t√©s √©gaux',
      'Un quadrilat√®re qui a 1 paire de c√¥t√©s parall√®les',
      'Un polygone √† 3 c√¥t√©s'
    ]
  },
  {
    id: 'rectangle',
    terme: 'Rectangle',
    definition: 'Un quadrilat√®re qui a 4 angles droits',
    image: 'images/geometrie/rectangle.svg',
    reponses: [
      'Un quadrilat√®re avec 4 c√¥t√©s √©gaux',
      'Un quadrilat√®re qui a 4 angles droits',
      'Un polygone √† 5 c√¥t√©s'
    ]
  },
  {
    id: 'carre',
    terme: 'Carr√©',
    definition: 'Un quadrilat√®re avec quatre c√¥t√©s √©gaux et quatre angles droits',
    image: 'images/geometrie/carre.svg',
    reponses: [
      'Un quadrilat√®re avec 4 c√¥t√©s √©gaux et 4 angles droits',
      'Un quadrilat√®re avec 2 paires de c√¥t√©s √©gaux',
      'Un polygone √† 5 c√¥t√©s √©gaux'
    ]
  },
  {
    id: 'triangle',
    terme: 'Triangle',
    definition: 'Un polygone √† trois c√¥t√©s et trois angles',
    image: 'images/geometrie/triangle.svg',
    reponses: [
      'Un polygone √† trois c√¥t√©s',
      'Un polygone √† quatre c√¥t√©s',
      'Un polygone √† cinq c√¥t√©s'
    ]
  },
  {
    id: 'cercle',
    terme: 'Cercle',
    definition: 'Une figure plane dont tous les points sont √† √©gale distance d\'un point central',
    image: 'images/geometrie/cercle.svg',
    reponses: [
      'Figure dont tous les points sont √† √©gale distance du centre',
      'Figure √† quatre c√¥t√©s √©gaux',
      'Figure √† trois c√¥t√©s',
      'Figure √† cinq c√¥t√©s'
    ]
  },
  {
    id: 'rectangle',
    terme: 'rectangle',
    definition: 'Un quadrilat√®re avec quatre angles droits et des c√¥t√©s oppos√©s de m√™me longueur.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Rectangle_Geometry_Vector.svg/1200px-Rectangle_Geometry_Vector.svg.png',
    reponses: [
      'Quadrilat√®re avec quatre angles droits et c√¥t√©s oppos√©s √©gaux',
      'Figure √† trois c√¥t√©s',
      'Figure ronde',
      'Figure √† six c√¥t√©s √©gaux'
    ]
  },
  {
    terme: 'losange',
    definition: 'Un quadrilat√®re dont les quatre c√¥t√©s sont de m√™me longueur et dont les c√¥t√©s oppos√©s sont parall√®les.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Rhombus_1.svg/1200px-Rhombus_1.svg.png',
    reponses: [
      'Quadrilat√®re avec quatre c√¥t√©s √©gaux et c√¥t√©s oppos√©s parall√®les',
      'Figure √† trois c√¥t√©s √©gaux',
      'Figure √† quatre angles droits',
      'Figure √† cinq c√¥t√©s'
    ]
  },
  {
    terme: 'parall√©logramme',
    definition: 'Un quadrilat√®re dont les c√¥t√©s oppos√©s sont parall√®les et de m√™me longueur.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Parallelogram_geometry.png/1200px-Parallelogram_geometry.png',
    reponses: [
      'Quadrilat√®re avec c√¥t√©s oppos√©s parall√®les et de m√™me longueur',
      'Figure √† trois c√¥t√©s',
      'Figure ronde',
      'Figure √† six c√¥t√©s √©gaux'
    ]
  },
  {
    terme: 'trap√®ze',
    definition: 'Un quadrilat√®re qui a au moins une paire de c√¥t√©s parall√®les.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Trapezoid_%28trapezium%29.svg/1200px-Trapezoid_%28trapezium%29.svg.png',
    reponses: [
      'Quadrilat√®re avec au moins une paire de c√¥t√©s parall√®les',
      'Figure √† trois c√¥t√©s',
      'Figure √† quatre c√¥t√©s √©gaux',
      'Figure ronde'
    ]
  },
  {
    terme: 'pentagone',
    definition: 'Un polygone √† cinq c√¥t√©s et cinq angles.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Pentagon.svg/1200px-Pentagon.svg.png',
    reponses: [
      'Polygone √† cinq c√¥t√©s et cinq angles',
      'Figure √† trois c√¥t√©s',
      'Figure √† quatre c√¥t√©s √©gaux',
      'Figure ronde'
    ]
  },
  {
    terme: 'hexagone',
    definition: 'Un polygone √† six c√¥t√©s et six angles.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Regular_hexagon.svg/1200px-Regular_hexagon.svg.png',
    reponses: [
      'Polygone √† six c√¥t√©s et six angles',
      'Figure √† cinq c√¥t√©s',
      'Figure √† quatre c√¥t√©s √©gaux',
      'Figure √† trois c√¥t√©s'
    ]
  },
  {
    terme: 'octogone',
    definition: 'Un polygone √† huit c√¥t√©s et huit angles.',
    image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Regular_octagon.svg/1200px-Regular_octagon.svg.png',
    reponses: [
      'Polygone √† huit c√¥t√©s et huit angles',
      'Figure √† six c√¥t√©s',
      'Figure √† cinq c√¥t√©s',
      'Figure √† quatre c√¥t√©s √©gaux'
    ]
  }
];

// Variables d'√©tat pour le jeu de d√©finitions
let definitionsRestantes = [];
let definitionActuelle = null;
let reponsesMelangees = [];
let reponseCorrecte = '';
let reponseSelectionnee = '';
let scoreDefinitions = 0;
let totalDefinitions = 0;

// Initialiser le jeu de d√©finitions
function initialiserJeuDefinitions() {
  // Copier toutes les d√©finitions
  definitionsRestantes = [...definitionsData];
  scoreDefinitions = 0;
  totalDefinitions = definitionsData.length;
  
  // M√©langer les d√©finitions
  definitionsRestantes = melangerTableau(definitionsRestantes);
  
  // Afficher la premi√®re d√©finition
  afficherDefinitionSuivante();
  
  // Mettre √† jour le score
  document.getElementById('score-definitions').textContent = scoreDefinitions;
  document.getElementById('total-definitions').textContent = totalDefinitions;
}

// Afficher une d√©finition al√©atoire
function afficherDefinitionSuivante() {
  const definitionsList = document.getElementById('definitions-list');
  const shapesContainer = document.getElementById('shapes-container');
  const feedbackDef = document.getElementById('feedback-def');
  
  // R√©initialiser la r√©ponse s√©lectionn√©e
  reponseSelectionnee = '';
  
  // R√©initialiser l'interface
  definitionsList.innerHTML = '';
  shapesContainer.innerHTML = '';
  feedbackDef.textContent = '';
  feedbackDef.className = 'feedback-def';
  document.getElementById('verifier-def').style.display = 'inline-block';
  document.getElementById('suivant-def').style.display = 'none';
  
  // V√©rifier s'il reste des d√©finitions
  if (definitionsRestantes.length === 0) {
    // Toutes les d√©finitions ont √©t√© vues
    definitionsList.innerHTML = '<div class="feedback correct">F√©licitations ! Vous avez termin√© toutes les d√©finitions. Score final : ' + scoreDefinitions + ' / ' + totalDefinitions + '</div>';
    document.getElementById('verifier-def').style.display = 'none';
    document.getElementById('suivant-def').style.display = 'none';
    return;
  }
  
  // Prendre la premi√®re d√©finition de la liste
  definitionActuelle = definitionsRestantes.shift();
  
  // M√©langer les r√©ponses
  reponsesMelangees = melangerTableau([...definitionActuelle.reponses]);
  reponseCorrecte = definitionActuelle.definition;
  
  // Afficher le terme √† d√©finir
  const termeElement = document.createElement('h3');
  termeElement.textContent = `Quelle est la d√©finition d'un ${definitionActuelle.terme} ?`;
  definitionsList.appendChild(termeElement);
  
  // Afficher les r√©ponses possibles
  reponsesMelangees.forEach((reponse, index) => {
    const reponseElement = document.createElement('div');
    reponseElement.className = 'definition-item';
    reponseElement.textContent = reponse;
    reponseElement.setAttribute('data-reponse', reponse);
    reponseElement.setAttribute('draggable', 'true');
    
    // Gestion du glisser-d√©poser
    reponseElement.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/plain', reponse);
      reponseElement.classList.add('dragging');
    });
    
    reponseElement.addEventListener('dragend', () => {
      reponseElement.classList.remove('dragging');
    });
    
    // Gestion du clic
    reponseElement.addEventListener('click', () => {
      document.querySelectorAll('.definition-item').forEach(item => {
        item.classList.remove('selected');
      });
      reponseElement.classList.add('selected');
      reponseSelectionnee = reponse;
    });
    
    definitionsList.appendChild(reponseElement);
  });
  
  // Configurer la zone de d√©p√¥t
  const shapeTarget = document.createElement('div');
  shapeTarget.className = 'shape-target';
  shapeTarget.innerHTML = `
    <img src="${definitionActuelle.image}" alt="${definitionActuelle.terme}">
    <p>D√©posez la d√©finition ici</p>
  `;
  
  // Gestion des √©v√©nements de glisser-d√©poser
  shapeTarget.addEventListener('dragover', (e) => {
    e.preventDefault();
    shapeTarget.classList.add('highlight');
  });
  
  shapeTarget.addEventListener('dragleave', () => {
    shapeTarget.classList.remove('highlight');
  });
  
  shapeTarget.addEventListener('drop', (e) => {
    e.preventDefault();
    shapeTarget.classList.remove('highlight');
    
    const reponse = e.dataTransfer.getData('text/plain');
    reponseSelectionnee = reponse;
    
    // Mettre en surbrillance la r√©ponse s√©lectionn√©e
    document.querySelectorAll('.definition-item').forEach(item => {
      item.classList.remove('selected');
      if (item.textContent === reponse) {
        item.classList.add('selected');
      }
    });
    
    // Afficher la r√©ponse dans la zone de d√©p√¥t
    shapeTarget.innerHTML = `
      <img src="${definitionActuelle.image}" alt="${definitionActuelle.terme}">
      <p>${reponse}</p>
    `;
  });
  
  shapesContainer.appendChild(shapeTarget);
}

// V√©rifier la r√©ponse s√©lectionn√©e
function verifierReponseDefinition() {
  const feedbackDef = document.getElementById('feedback-def');
  const shapeTarget = document.querySelector('.shape-target');
  const verifierBtn = document.getElementById('verifier-def');
  const suivantBtn = document.getElementById('suivant-def');
  
  if (!reponseSelectionnee) {
    feedbackDef.textContent = 'Veuillez s√©lectionner une r√©ponse.';
    feedbackDef.className = 'feedback-def incorrect';
    feedbackDef.style.display = 'block';
    return;
  }
  
  const estCorrect = reponseSelectionnee === reponseCorrecte;
  
  if (estCorrect) {
    scoreDefinitions++;
    feedbackDef.textContent = 'Correct ! ' + definitionActuelle.definition;
    feedbackDef.className = 'feedback-def correct';
    shapeTarget.classList.add('correct');
  } else {
    feedbackDef.innerHTML = `Incorrect. La bonne r√©ponse √©tait : <strong>${reponseCorrecte}</strong>`;
    feedbackDef.className = 'feedback-def incorrect';
    shapeTarget.classList.add('incorrect');
  }
  
  // Mettre √† jour le score
  document.getElementById('score-definitions').textContent = scoreDefinitions;
  
  // Changer les boutons
  verifierBtn.style.display = 'none';
  suivantBtn.style.display = 'inline-block';
  
  // D√©sactiver le glisser-d√©poser
  document.querySelectorAll('.definition-item').forEach(item => {
    item.setAttribute('draggable', 'false');
  });
}

// Charger les donn√©es de g√©om√©trie
function chargerDonneesGeometrie() {
  return fetch('geometrie.json')
    .then(response => response.json())
    .then(data => {
      geometrieData = data;
      return data;
    })
    .catch(error => {
      console.error('Erreur lors du chargement des donn√©es de g√©om√©trie :', error);
      throw error;
    });
}

// Afficher le verbe actuel √† conjuguer
function afficherVerbeActuel() {
  if (!verbesData || verbesData.length === 0) {
    console.error('Aucun verbe disponible');
    return;
  }
  
  const verbe = verbesData[currentVerbeIndex];
  document.getElementById('verbe-infinitif').textContent = verbe.infinitif;
  
  // R√©initialiser les champs de saisie et les retours visuels
  ['je', 'tu', 'il', 'nous', 'vous', 'ils'].forEach(personne => {
    document.getElementById(`conj-${personne}`).value = '';
    document.getElementById(`result-${personne}`).textContent = '';
    document.getElementById(`result-${personne}`).className = 'conjugaison-result';
  });
  
  // Activer tous les champs de saisie
  document.querySelectorAll('.conjugaison-input').forEach(input => {
    input.disabled = false;
  });
  
  // R√©initialiser le feedback
  document.getElementById('conjugaison-feedback').textContent = '';
  document.getElementById('conjugaison-feedback').className = 'conjugaison-feedback';
  
  // Mettre √† jour le compteur
  document.getElementById('verbe-compteur').textContent = `${currentVerbeIndex + 1} / ${totalVerbes}`;
}

// Initialiser le jeu de conjugaison
function initConjugaison() {
  fetch('futur-conjugaison.json')
    .then(response => response.json())
    .then(data => {
      verbesData = data.verbes;
      totalVerbes = verbesData.length;
      currentVerbeIndex = 0;
      afficherVerbeActuel();
      document.getElementById('score-conjugaison').textContent = scoreConjugaison;
      document.getElementById('total-verbes').textContent = totalVerbes;
      
      // Ajouter l'√©couteur pour le bouton de v√©rification
      document.getElementById('check-conjugaison').addEventListener('click', verifierConjugaison);
      
      // Ajouter l'√©couteur pour le bouton suivant
      document.getElementById('next-conjugaison').addEventListener('click', () => {
        currentVerbeIndex = (currentVerbeIndex + 1) % verbesData.length;
        afficherVerbeActuel();
      });
    })
    .catch(error => {
      console.error('Erreur lors du chargement des verbes :', error);
      document.getElementById('conjugaison-feedback').innerHTML = 'Erreur lors du chargement des verbes. Veuillez r√©essayer.';
    });
}

// V√©rifier les r√©ponses de conjugaison
function verifierConjugaison() {
  if (!verbesData || currentVerbeIndex >= verbesData.length) return;
  
  const verbe = verbesData[currentVerbeIndex];
  let toutesCorrectes = true;
  
  // V√©rifier chaque personne
  ['je', 'tu', 'il', 'nous', 'vous', 'ils'].forEach(personne => {
    const reponse = document.getElementById(`conj-${personne}`).value.trim().toLowerCase();
    const reponseCorrecte = verbe[`${personne}_futur`].toLowerCase();
    const resultElement = document.getElementById(`result-${personne}`);
    
    if (reponse === reponseCorrecte) {
      resultElement.textContent = '‚úì';
      resultElement.className = 'conjugaison-result correct';
    } else {
      resultElement.textContent = reponseCorrecte;
      resultElement.className = 'conjugaison-result incorrect';
      toutesCorrectes = false;
    }
  });
  
  // Mettre √† jour le score
  if (toutesCorrectes) {
    scoreConjugaison++;
    document.getElementById('score-conjugaison').textContent = scoreConjugaison;
    document.getElementById('conjugaison-feedback').textContent = 'Bravo ! Toutes les r√©ponses sont correctes !';
    document.getElementById('conjugaison-feedback').className = 'conjugaison-feedback success';
  } else {
    document.getElementById('conjugaison-feedback').textContent = 'Certaines r√©ponses sont incorrectes. Corrigez-les et r√©essayez.';
    document.getElementById('conjugaison-feedback').className = 'conjugaison-feedback error';
  }
  
  // Activer le bouton suivant
  document.getElementById('next-conjugaison').disabled = false;
}

// Fonction pour charger les donn√©es de g√©om√©trie
function chargerDonneesGeometrie() {
  return fetch('geometrie.json')
    .then(response => {
      if (!response.ok) {
        throw new Error('Erreur de chargement des donn√©es de g√©om√©trie');
      }
      return response.json();
    })
    .then(data => {
      window.geometrieData = data;
      console.log('Donn√©es de g√©om√©trie charg√©es:', window.geometrieData);
      return data;
    })
    .catch(error => {
      console.error('Erreur lors du chargement des donn√©es de g√©om√©trie:', error);
      document.getElementById('jeu-geometrie').innerHTML = 
        '<p class="error">Erreur de chargement des donn√©es de g√©om√©trie. Veuillez recharger la page.</p>';
      throw error; // Propager l'erreur
    });
}

// Initialisation du jeu de d√©finitions de g√©om√©trie
function initialiserJeuDefinitions() {
  console.log('Initialisation du jeu de d√©finitions');
  
  // V√©rifier que les donn√©es sont disponibles
  if (!window.definitionsData || !Array.isArray(window.definitionsData) || window.definitionsData.length === 0) {
    console.error('Aucune donn√©e de d√©finition disponible');
    document.getElementById('feedback-def').textContent = 'Erreur : Aucune donn√©e de d√©finition disponible';
    return;
  }
  
  // Initialiser les variables du jeu
  window.definitionsRestantes = [...window.definitionsData];
  window.definitionActuelle = null;
  window.reponsesMelangees = [];
  window.reponseCorrecte = '';
  window.reponseSelectionnee = null;
  window.scoreDefinitions = 0;
  window.totalDefinitions = window.definitionsData.length;
  
  // M√©langer les d√©finitions
  window.definitionsRestantes = melangerTableau(window.definitionsRestantes);
  
  // Afficher la premi√®re d√©finition
  afficherDefinitionSuivante();
  
  // Mettre √† jour le score
  document.getElementById('score-definitions').textContent = window.scoreDefinitions;
  document.getElementById('total-definitions').textContent = window.totalDefinitions;
  
  // Ajouter les √©couteurs d'√©v√©nements
  document.getElementById('verifier-def').addEventListener('click', verifierReponseDefinition);
  document.getElementById('suivant-def').addEventListener('click', afficherDefinitionSuivante);
  
  console.log('Jeu de d√©finitions initialis√© avec', window.definitionsRestantes.length, 'd√©finitions');
}

// Afficher la d√©finition suivante
function afficherDefinitionSuivante() {
  console.log('Affichage de la d√©finition suivante');
  
  // R√©initialiser l'interface
  document.getElementById('definitions-list').innerHTML = '';
  document.getElementById('shapes-container').innerHTML = '';
  document.getElementById('feedback-def').textContent = '';
  document.getElementById('verifier-def').style.display = 'inline-block';
  document.getElementById('suivant-def').style.display = 'none';
  
  // V√©rifier s'il reste des d√©finitions
  if (window.definitionsRestantes.length === 0) {
    // Toutes les d√©finitions ont √©t√© affich√©es
    document.getElementById('definitions-list').innerHTML = '<p>F√©licitations ! Vous avez termin√© toutes les d√©finitions.</p>';
    document.getElementById('verifier-def').style.display = 'none';
    document.getElementById('suivant-def').style.display = 'none';
    return;
  }
  
  // Prendre la prochaine d√©finition
  window.definitionActuelle = window.definitionsRestantes.pop();
  
  // Afficher la d√©finition
  const definitionElement = document.createElement('div');
  definitionElement.className = 'definition-item';
  definitionElement.textContent = window.definitionActuelle.definition;
  document.getElementById('definitions-list').appendChild(definitionElement);
  
  // M√©langer les r√©ponses
  window.reponsesMelangees = melangerTableau([...window.definitionActuelle.termes]);
  window.reponseCorrecte = window.definitionActuelle.termeCorrect;
  
  // Afficher les formes (r√©ponses possibles)
  window.reponsesMelangees.forEach((terme, index) => {
    const shapeElement = document.createElement('div');
    shapeElement.className = 'shape-item';
    shapeElement.dataset.terme = terme;
    shapeElement.innerHTML = `
      <img src="images/geometrie/${terme}.svg" alt="${terme}" class="shape-image">
      <div class="shape-name">${terme}</div>
    `;
    
    // Ajouter un √©couteur d'√©v√©nements pour la s√©lection
    shapeElement.addEventListener('click', () => {
      document.querySelectorAll('.shape-item').forEach(item => {
        item.classList.remove('selected');
      });
      shapeElement.classList.add('selected');
      window.reponseSelectionnee = terme;
    });
    
    document.getElementById('shapes-container').appendChild(shapeElement);
  });
  
  console.log('D√©finition affich√©e :', window.definitionActuelle);
}

// V√©rifier la r√©ponse s√©lectionn√©e
function verifierReponseDefinition() {
  console.log('V√©rification de la r√©ponse');
  
  if (!window.reponseSelectionnee) {
    document.getElementById('feedback-def').textContent = 'Veuillez s√©lectionner une r√©ponse';
    document.getElementById('feedback-def').style.color = 'red';
    return;
  }
  
  const feedbackElement = document.getElementById('feedback-def');
  
  if (window.reponseSelectionnee === window.reponseCorrecte) {
    // Bonne r√©ponse
    window.scoreDefinitions++;
    feedbackElement.textContent = 'Bravo ! Bonne r√©ponse !';
    feedbackElement.style.color = 'green';
    document.getElementById('score-definitions').textContent = window.scoreDefinitions;
  } else {
    // Mauvaise r√©ponse
    feedbackElement.textContent = `Incorrect. La bonne r√©ponse √©tait : ${window.reponseCorrecte}`;
    feedbackElement.style.color = 'red';
  }
  
  // Mettre √† jour l'interface
  document.getElementById('verifier-def').style.display = 'none';
  document.getElementById('suivant-def').style.display = 'inline-block';
  
  // Mettre en √©vidence la bonne r√©ponse
  document.querySelectorAll('.shape-item').forEach(item => {
    if (item.dataset.terme === window.reponseCorrecte) {
      item.classList.add('correct-answer');
    }
  });
}

// Initialisation du jeu de g√©om√©trie
function initialiserJeuGeometrie() {
  console.log('Initialisation du jeu de g√©om√©trie...');
  
  // R√©initialiser les variables du jeu
  formesJouees = [];
  
  // V√©rifier si les donn√©es sont d√©j√† charg√©es
  if (window.geometrieData) {
    console.log('Donn√©es de g√©om√©trie d√©j√† charg√©es');
    configurerBoutonsNiveaux();
    return;
  }
  
  // Charger les donn√©es de g√©om√©trie
  console.log('Chargement des donn√©es de g√©om√©trie...');
  chargerDonneesGeometrie()
    .then(() => {
      console.log('Donn√©es de g√©om√©trie charg√©es avec succ√®s');
      configurerBoutonsNiveaux();
    })
    .catch(error => {
      console.error('Erreur lors du chargement des donn√©es de g√©om√©trie:', error);
      const container = document.querySelector('.game-geometrie');
      if (container) {
        container.innerHTML = '<p class="error">Erreur de chargement des donn√©es de g√©om√©trie. Veuillez recharger la page.</p>';
      }
    });
}

// Configurer les boutons de niveau
function configurerBoutonsNiveaux() {
  const boutonsNiveau = document.querySelectorAll('.niveau-btn');
  if (boutonsNiveau.length === 0) {
    console.error('Aucun bouton de niveau trouv√©');
    return;
  }
  
  console.log('Configuration des boutons de niveau...');
  
  // Ajouter les √©couteurs d'√©v√©nements pour les boutons de niveau
  boutonsNiveau.forEach(btn => {
    btn.addEventListener('click', (e) => {
      const niveauId = e.currentTarget.getAttribute('data-niveau');
      console.log('Niveau s√©lectionn√©:', niveauId);
      demarrerNiveau(niveauId);
    });
  });
  
  // Ajouter les √©couteurs d'√©v√©nements pour les boutons d'action
  const btnValider = document.getElementById('btn-valider');
  const btnSuivant = document.getElementById('btn-suivant');
  const btnRecommencer = document.getElementById('recommencer');
  
  if (btnValider) {
    btnValider.addEventListener('click', validerReponse);
  } else {
    console.error('Bouton valider non trouv√©');
  }
  
  if (btnSuivant) {
    btnSuivant.addEventListener('click', afficherFormeSuivante);
  } else {
    console.error('Bouton suivant non trouv√©');
  }
  
  if (btnRecommencer) {
    btnRecommencer.addEventListener('click', recommencerNiveau);
  } else {
    console.error('Bouton recommencer non trouv√©');
  }
  
  console.log('Boutons configur√©s avec succ√®s');
}

// D√©marrer un niveau sp√©cifique
function demarrerNiveau(niveauId) {
  console.log('D√©marrage du niveau:', niveauId);
  
  // V√©rifier que les donn√©es sont charg√©es
  if (!window.geometrieData) {
    console.error('Donn√©es de g√©om√©trie non charg√©es');
    // Essayer de recharger les donn√©es
    initialiserJeuGeometrie();
    return;
  }
  
  if (!window.geometrieData.niveaux) {
    console.error('Aucun niveau trouv√© dans les donn√©es de g√©om√©trie');
    return;
  }
  
  // Trouver le niveau demand√©
  const niveauTrouve = window.geometrieData.niveaux.find(n => n.id === niveauId);
  if (!niveauTrouve) {
    console.error('Niveau non trouv√© :', niveauId);
    return;
  }
  
  // Cr√©er une copie profonde du niveau
  niveauActuel = JSON.parse(JSON.stringify(niveauTrouve));
  
  // V√©rifier que le niveau a des formes
  if (!niveauActuel.formes || niveauActuel.formes.length === 0) {
    console.error('Aucune forme trouv√©e pour ce niveau');
    return;
  }
  
  // M√©langer les formes pour ce niveau
  niveauActuel.formes = melangerTableau([...niveauActuel.formes]);
  
  // Mettre √† jour l'interface
  const titreElement = document.getElementById('niveau-titre');
  const descriptionElement = document.getElementById('niveau-description');
  const formeContainer = document.getElementById('forme-container');
  const descriptionContainer = document.querySelector('.niveau-description');
  const resultatsElement = document.getElementById('resultats');
  
  if (titreElement) titreElement.textContent = niveauActuel.nom || 'Niveau sans nom';
  if (descriptionElement) descriptionElement.textContent = niveauActuel.description || '';
  if (formeContainer) formeContainer.style.display = 'block';
  if (descriptionContainer) descriptionContainer.style.display = 'block';
  if (resultatsElement) resultatsElement.style.display = 'none';
  
  // R√©initialiser les variables du jeu
  scoreGeometrie = 0;
  formesJouees = [];
  totalFormes = niveauActuel.formes.length;
  
  console.log(`Niveau "${niveauActuel.nom}" d√©marr√© avec ${totalFormes} formes`);
  
  // Afficher la premi√®re forme
  afficherFormeAleatoire();
}

// Afficher une forme al√©atoire
function afficherFormeAleatoire() {
  console.log('Affichage d\'une forme al√©atoire...');
  
  // V√©rifier que le niveau est correctement initialis√©
  if (!niveauActuel || !niveauActuel.formes) {
    console.error('Niveau non initialis√© ou sans formes');
    return;
  }
  
  // R√©initialiser l'interface
  const feedbackElement = document.getElementById('feedback');
  const btnValider = document.getElementById('btn-valider');
  const btnSuivant = document.getElementById('btn-suivant');
  const definitionElement = document.getElementById('definition');
  
  if (feedbackElement) feedbackElement.style.display = 'none';
  if (btnValider) btnValider.disabled = true;
  if (btnSuivant) btnSuivant.style.display = 'none';
  if (definitionElement) definitionElement.style.display = 'none';
  
  // Choisir une forme al√©atoire qui n'a pas encore √©t√© jou√©e
  const formesDisponibles = niveauActuel.formes.filter((_, index) => !formesJouees.includes(index));
  
  if (formesDisponibles.length === 0) {
    console.log('Toutes les formes ont √©t√© jou√©es');
    afficherResultats();
    return;
  }
  
  const formeIndex = Math.floor(Math.random() * formesDisponibles.length);
  formeActuelle = formesDisponibles[formeIndex];
  formesJouees.push(niveauActuel.formes.findIndex(f => f === formeActuelle));
  
  console.log('Forme s√©lectionn√©e:', formeActuelle);
  
  // Mettre √† jour l'image de la forme
  const formeImage = document.getElementById('forme-image');
  if (formeImage && formeActuelle.image) {
    formeImage.innerHTML = `<img src="images/geometrie/${formeActuelle.image}" alt="${formeActuelle.type || 'Forme g√©om√©trique'}">`;
  } else {
    console.error('Impossible d\'afficher l\'image de la forme');
    if (formeImage) formeImage.innerHTML = '<p>Image non disponible</p>';
  }
  
  // Mettre √† jour les boutons de r√©ponse
  const reponsesContainer = document.getElementById('reponse-boutons') || document.createElement('div');
  reponsesContainer.innerHTML = '';
  
  // D√©terminer les r√©ponses possibles en fonction du niveau
  let reponses = [];
  
  if (niveauActuel.id === 'polygone-ou-non') {
    reponses = ['Polygone', 'Non-polygone'];
  } else if (niveauActuel.id === 'type-polygone') {
    reponses = ['Triangle', 'Quadrilat√®re'];
  } else if (niveauActuel.id === 'quadrilateres') {
    reponses = ['Trap√®ze', 'Parall√©logramme', 'Rectangle', 'Carr√©'];
  } else {
    console.error('Type de niveau non reconnu:', niveauActuel.id);
    reponses = [];
  }
  
  console.log('R√©ponses possibles:', reponses);
  
  // Cr√©er les boutons de r√©ponse
  reponses.forEach(reponse => {
    const btn = document.createElement('button');
    btn.className = 'reponse-btn';
    btn.textContent = reponse;
    btn.addEventListener('click', () => {
      // D√©s√©lectionner tous les boutons
      document.querySelectorAll('.reponse-btn').forEach(b => b.classList.remove('selected'));
      // S√©lectionner le bouton cliqu√©
      btn.classList.add('selected');
      reponseSelectionnee = reponse;
      console.log('R√©ponse s√©lectionn√©e:', reponse);
      // Valider automatiquement la r√©ponse
      validerReponse();
    });
    reponsesContainer.appendChild(btn);
  });
  
  // R√©initialiser la s√©lection
  reponseSelectionnee = null;
  
  // Cacher le bouton Valider puisqu'on valide automatiquement
  if (btnValider) btnValider.style.display = 'none';
}

// Valider la r√©ponse s√©lectionn√©e
function validerReponse() {
  console.log('Validation de la r√©ponse...');
  
  // V√©rifier s'il y a une r√©ponse s√©lectionn√©e
  if (reponseSelectionnee === null) {
    console.warn('Aucune r√©ponse s√©lectionn√©e');
    return;
  }
  
  // V√©rifier que les √©l√©ments n√©cessaires sont pr√©sents
  if (!niveauActuel || !formeActuelle) {
    console.error('Donn√©es manquantes pour valider la r√©ponse');
    return;
  }
  
  const feedback = document.getElementById('feedback');
  const feedbackTexte = document.getElementById('feedback-texte');
  const explication = document.getElementById('explication');
  const definition = document.getElementById('definition');
  const definitionTexte = document.getElementById('definition-texte');
  
  if (!feedback || !feedbackTexte || !explication || !definition || !definitionTexte) {
    console.error('√âl√©ments d\'interface manquants');
    return;
  }
  
  // V√©rifier si la r√©ponse est correcte
  let estCorrect = false;
  let reponseAttendue = '';
  let explicationTexte = '';
  
  try {
    if (niveauActuel.id === 'polygone-ou-non') {
      reponseAttendue = formeActuelle.estPolygone ? 'Polygone' : 'Non-polygone';
      estCorrect = reponseSelectionnee === reponseAttendue;
      
      if (estCorrect) {
        if (formeActuelle.estPolygone) {
          explicationTexte = 'Exact ! Cette forme est un polygone car elle est compos√©e de segments droits qui se referment pour former une figure plane ferm√©e.';
        } else {
          explicationTexte = 'Exact ! Cette forme n\'est pas un polygone car elle contient des courbes ou n\'est pas une figure ferm√©e.';
        }
      } else {
        if (formeActuelle.estPolygone) {
          explicationTexte = `Non, cette forme est bien un polygone. Un polygone est une figure plane ferm√©e compos√©e de segments droits. ${formeActuelle.explication || ''}`;
        } else {
          explicationTexte = `Non, cette forme n'est pas un polygone. ${formeActuelle.explication || ''}`;
        }
      }
      
    } else if (niveauActuel.id === 'type-polygone') {
      reponseAttendue = formeActuelle.type === 'triangle' ? 'Triangle' : 'Quadrilat√®re';
      estCorrect = reponseSelectionnee === reponseAttendue;
      
      if (estCorrect) {
        if (formeActuelle.type === 'triangle') {
          explicationTexte = 'Exact ! Cette forme est un triangle car elle a 3 c√¥t√©s.';
        } else {
          explicationTexte = 'Exact ! Cette forme est un quadrilat√®re car elle a 4 c√¥t√©s.';
        }
      } else {
        if (formeActuelle.type === 'triangle') {
          explicationTexte = `Non, cette forme est un triangle car elle a 3 c√¥t√©s. Un triangle est un polygone √† trois c√¥t√©s.`;
        } else {
          explicationTexte = `Non, cette forme est un quadrilat√®re car elle a 4 c√¥t√©s. Un quadrilat√®re est un polygone √† quatre c√¥t√©s.`;
        }
      }
      
    } else if (niveauActuel.id === 'quadrilateres') {
      reponseAttendue = formeActuelle.type && typeof formeActuelle.type === 'string' 
        ? formeActuelle.type.charAt(0).toUpperCase() + formeActuelle.type.slice(1)
        : 'Inconnu';
        
      estCorrect = reponseSelectionnee === reponseAttendue;
      
      if (estCorrect) {
        switch(formeActuelle.type) {
          case 'trapeze':
            explicationTexte = 'Exact ! C\'est un trap√®ze car il a au moins une paire de c√¥t√©s parall√®les.';
            break;
          case 'parallelogramme':
            explicationTexte = 'Exact ! C\'est un parall√©logramme car ses c√¥t√©s oppos√©s sont parall√®les et de m√™me longueur.';
            break;
          case 'rectangle':
            explicationTexte = 'Exact ! C\'est un rectangle car il a quatre angles droits et des c√¥t√©s oppos√©s parall√®les et de m√™me longueur.';
            break;
          case 'carre':
            explicationTexte = 'Exact ! C\'est un carr√© car il a quatre c√¥t√©s de m√™me longueur et quatre angles droits.';
            break;
          case 'losange':
            explicationTexte = 'Exact ! C\'est un losange car il a quatre c√¥t√©s de m√™me longueur et des c√¥t√©s oppos√©s parall√®les.';
            break;
          default:
            explicationTexte = 'Bonne r√©ponse !';
            console.warn('Type de quadrilat√®re non reconnu:', formeActuelle.type);
        }
      } else {
        switch(formeActuelle.type) {
          case 'trapeze':
            explicationTexte = `Non, c'est un trap√®ze. Un trap√®ze est un quadrilat√®re qui a au moins une paire de c√¥t√©s parall√®les.`;
            break;
          case 'parallelogramme':
            explicationTexte = `Non, c'est un parall√©logramme. Un parall√©logramme a ses c√¥t√©s oppos√©s parall√®les et de m√™me longueur.`;
            break;
          case 'rectangle':
            explicationTexte = `Non, c'est un rectangle. Un rectangle a quatre angles droits et des c√¥t√©s oppos√©s parall√®les et de m√™me longueur.`;
            break;
          case 'carre':
            explicationTexte = `Non, c'est un carr√©. Un carr√© a quatre c√¥t√©s de m√™me longueur et quatre angles droits.`;
            break;
          case 'losange':
            explicationTexte = `Non, c'est un losange. Un losange a quatre c√¥t√©s de m√™me longueur et des c√¥t√©s oppos√©s parall√®les.`;
            break;
          default:
            explicationTexte = `La bonne r√©ponse √©tait : ${reponseAttendue}`;
            console.warn('Type de quadrilat√®re non reconnu:', formeActuelle.type);
        }
      }
    } else {
      console.error('Type de niveau non pris en charge:', niveauActuel.id);
      return;
    }
    
    // Mettre √† jour le score et afficher le feedback
    if (estCorrect) {
      scoreGeometrie++;
      console.log('Bonne r√©ponse ! Score:', scoreGeometrie);
    } else {
      console.log('Mauvaise r√©ponse. La bonne r√©ponse √©tait:', reponseAttendue);
    }
    
    // Mettre √† jour l'interface utilisateur
    feedback.className = estCorrect ? 'feedback correct' : 'feedback incorrect';
    feedbackTexte.textContent = estCorrect ? 'Bonne r√©ponse !' : `La bonne r√©ponse √©tait : ${reponseAttendue}`;
    explication.textContent = explicationTexte;
    
    // Afficher la d√©finition si disponible
    if (window.geometrieData && 
        window.geometrieData.definitions && 
        formeActuelle.type && 
        window.geometrieData.definitions[formeActuelle.type]) {
      definitionTexte.textContent = window.geometrieData.definitions[formeActuelle.type];
      definition.style.display = 'block';
    } else {
      definition.style.display = 'none';
    }
    
    // Afficher le feedback
    feedback.style.display = 'block';
    
    // D√©sactiver tous les boutons de r√©ponse et mettre en √©vidence la bonne r√©ponse
    const boutonsReponse = document.querySelectorAll('.reponse-btn');
    if (boutonsReponse.length > 0) {
      boutonsReponse.forEach(btn => {
        btn.disabled = true;
        
        // Mettre en √©vidence la bonne r√©ponse
        const estBonneReponse = (niveauActuel.id === 'polygone-ou-non' && btn.textContent === reponseAttendue) ||
                              ((niveauActuel.id === 'type-polygone' || niveauActuel.id === 'quadrilateres') && 
                               btn.textContent.toLowerCase() === formeActuelle.type);
        
        if (estBonneReponse) {
          btn.classList.add('correct-answer');
        }
      });
    }
    
    // Mettre √† jour les boutons d'action
    const btnValider = document.getElementById('btn-valider');
    const btnSuivant = document.getElementById('btn-suivant');
    
    if (btnValider) btnValider.style.display = 'none';
    if (btnSuivant) btnSuivant.style.display = 'inline-block';
    
  } catch (error) {
    console.error('Erreur lors de la validation de la r√©ponse:', error);
    if (feedback && feedbackTexte) {
      feedback.className = 'feedback error';
      feedbackTexte.textContent = 'Une erreur est survenue. Veuillez r√©essayer.';
      feedback.style.display = 'block';
    }
  }
}

// Afficher la forme suivante
function afficherFormeSuivante() {
  console.log('Passage √† la forme suivante...');
  
  try {
    // V√©rifier qu'il reste des formes √† afficher
    if (formesJouees.length >= totalFormes) {
      console.log('Toutes les formes ont √©t√© jou√©es, affichage des r√©sultats');
      afficherResultats();
      return;
    }
    
    // R√©initialiser la s√©lection de r√©ponse
    reponseSelectionnee = null;
    
    // Afficher une nouvelle forme
    afficherFormeAleatoire();
    
  } catch (error) {
    console.error('Erreur lors du passage √† la forme suivante:', error);
    
    // Afficher un message d'erreur √† l'utilisateur
    const feedback = document.getElementById('feedback');
    const feedbackTexte = document.getElementById('feedback-texte');
    
    if (feedback && feedbackTexte) {
      feedback.className = 'feedback error';
      feedbackTexte.textContent = 'Une erreur est survenue lors du chargement de la prochaine forme.';
      feedback.style.display = 'block';
    }
    
    // Essayer d'afficher les r√©sultats en cas d'erreur
    try {
      afficherResultats();
    } catch (e) {
      console.error('Impossible d\'afficher les r√©sultats:', e);
    }
  }
}



// Afficher les r√©sultats finaux
function afficherResultats() {
  console.log('Affichage des r√©sultats finaux...');
  
  try {
    // Masquer le conteneur de forme s'il existe
    const formeContainer = document.getElementById('forme-container');
    if (formeContainer) {
      formeContainer.style.display = 'none';
    }
    
    // R√©cup√©rer les √©l√©ments d'interface
    const resultats = document.getElementById('resultats');
    const scoreElement = document.getElementById('score');
    const totalElement = document.getElementById('total');
    const messageElement = document.getElementById('message-score');
    
    // V√©rifier que les √©l√©ments existent
    if (!resultats || !scoreElement || !totalElement) {
      console.error('√âl√©ments d\'interface des r√©sultats manquants');
      return;
    }
    
    // Mettre √† jour les scores
    scoreElement.textContent = scoreGeometrie || 0;
    totalElement.textContent = totalFormes || 0;
    
    // Afficher un message personnalis√© en fonction du score
    if (messageElement) {
      const pourcentage = totalFormes > 0 ? Math.round((scoreGeometrie / totalFormes) * 100) : 0;
      
      if (pourcentage >= 90) {
        messageElement.textContent = 'Excellent travail ! Vous ma√Ætrisez parfaitement ce sujet !';
        messageElement.className = 'excellent';
      } else if (pourcentage >= 70) {
        messageElement.textContent = 'Bravo ! Bonne performance, continuez comme √ßa !';
        messageElement.className = 'bon';
      } else if (pourcentage >= 50) {
        messageElement.textContent = 'Pas mal ! Encore un peu de pratique pour vous perfectionner.';
        messageElement.className = 'moyen';
      } else {
        messageElement.textContent = 'Ne vous d√©couragez pas ! Revoyez les d√©finitions et r√©essayez.';
        messageElement.className = 'a-ameliorer';
      }
    }
    
    // Afficher la section des r√©sultats
    resultats.style.display = 'block';
    
    console.log(`R√©sultats affich√©s: ${scoreGeometrie}/${totalFormes} (${Math.round((scoreGeometrie / totalFormes) * 100)}%)`);
    
  } catch (error) {
    console.error('Erreur lors de l\'affichage des r√©sultats:', error);
    
    // Afficher un message d'erreur √† l'utilisateur
    const feedback = document.getElementById('feedback');
    const feedbackTexte = document.getElementById('feedback-texte');
    
    if (feedback && feedbackTexte) {
      feedback.className = 'feedback error';
      feedbackTexte.textContent = 'Une erreur est survenue lors de l\'affichage des r√©sultats.';
      feedback.style.display = 'block';
    }
  }
}

// Recommencer le niveau
function recommencerNiveau() {
  console.log('Recommencement du niveau...');
  
  try {
    // V√©rifier qu'un niveau est en cours
    if (!niveauActuel || !niveauActuel.id) {
      console.error('Aucun niveau en cours √† recommencer');
      
      // Essayer de revenir √† la s√©lection de niveau
      const selectionNiveau = document.querySelector('.niveau-selection');
      const interfaceJeu = document.getElementById('jeu-geometrie');
      
      if (selectionNiveau && interfaceJeu) {
        selectionNiveau.style.display = 'block';
        interfaceJeu.style.display = 'none';
      }
      
      return;
    }
    
    // R√©initialiser les variables du jeu
    scoreGeometrie = 0;
    reponseSelectionnee = null;
    formesJouees = [];
    
    console.log(`Niveau √† recommencer: ${niveauActuel.id}`);
    
    // Masquer les r√©sultats s'ils sont affich√©s
    const resultats = document.getElementById('resultats');
    if (resultats) {
      resultats.style.display = 'none';
    }
    
    // R√©afficher l'interface de jeu
    const interfaceJeu = document.getElementById('jeu-geometrie');
    if (interfaceJeu) {
      interfaceJeu.style.display = 'block';
    }
    
    // Red√©marrer le niveau
    demarrerNiveau(niveauActuel.id);
    
  } catch (error) {
    console.error('Erreur lors du recommencement du niveau:', error);
    
    // Afficher un message d'erreur √† l'utilisateur
    const feedback = document.getElementById('feedback');
    const feedbackTexte = document.getElementById('feedback-texte');
    
    if (feedback && feedbackTexte) {
      feedback.className = 'feedback error';
      feedbackTexte.textContent = 'Une erreur est survenue lors du recommencement du niveau.';
      feedback.style.display = 'block';
    }
    
    // Essayer de revenir √† la s√©lection de niveau
    try {
      const selectionNiveau = document.querySelector('.niveau-selection');
      if (selectionNiveau) {
        selectionNiveau.style.display = 'block';
      }
    } catch (e) {
      console.error('Impossible de revenir √† la s√©lection de niveau:', e);
    }
  }
}

// Ajouter les √©couteurs d'√©v√©nements pour le jeu de conjugaison
document.addEventListener('DOMContentLoaded', function() {
  // Initialisation du menu
  const menuBtn = document.querySelector('.menu-btn');
  if (menuBtn) {
    menuBtn.addEventListener('click', toggleMenu);
  }
  
  // Initialisation du jeu de g√©om√©trie
  initialiserJeuGeometrie();
  
  const checkBtn = document.getElementById('check-conjugaison');
  const nextBtn = document.getElementById('next-conjugaison');
  
  if (checkBtn) {
    checkBtn.addEventListener('click', checkConjugaison);
  }
  
  if (nextBtn) {
    nextBtn.addEventListener('click', nextVerbe);
  }
  
  // Valider la conjugaison avec la touche Entr√©e
  document.querySelectorAll('.conjugaison-input').forEach(input => {
    input.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        checkConjugaison();
      }
    });
  });
  
  // Initialiser le jeu de conjugaison
  initConjugaison();
});
</script>
</body>
</html>
