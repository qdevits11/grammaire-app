<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>R√©vision Grammaire</title>
  <link rel="stylesheet" href="style.css">
  <script>
  // D√©finition de la fonction checkFutur en premier
  function checkFutur(answer, game = 'futur') {
    console.log('=== FONCTION checkFutur APPEL√âE ===');
    console.log('Bouton cliqu√©:', answer);
    
    // Attendre que l'objet games soit disponible
    if (!window.games) {
      console.error('L\'objet games n\'est pas encore charg√©');
      return;
    }
    
    const gameData = window.games[game];
    if (!gameData) {
      console.error('Jeu non trouv√©:', game, 'Disponibles:', Object.keys(window.games));
      return;
    }
    
    // V√©rifier que l'index actuel est valide
    if (typeof gameData.current === 'undefined' || gameData.current === null) {
      console.error('Index actuel non d√©fini, r√©initialisation...');
      gameData.current = 0;
    }
    
    let currentData = gameData.data[gameData.current];
    if (!currentData) {
      console.error('Aucune donn√©e pour la phrase actuelle. Index:', gameData.current, 'Donn√©es:', gameData.data);
      // Essayer de r√©cup√©rer la premi√®re phrase
      if (gameData.data.length > 0) {
        console.log('Tentative de r√©cup√©ration de la premi√®re phrase...');
        gameData.current = 0;
        currentData = gameData.data[0];
      } else {
        return;
      }
    }
    
    console.log('Index actuel:', gameData.current, '/', gameData.data.length - 1);
    console.log('Toutes les donn√©es:', gameData.data);
    
    console.log('Donn√©es de la phrase actuelle:', currentData);
    
    const feedbackElement = document.getElementById('futur-feedback');
    
    // V√©rifier la r√©ponse
    const expectedAnswer = currentData.type;
    console.log('R√©ponse attendue:', expectedAnswer, 'R√©ponse donn√©e:', answer);
    
    if (answer === expectedAnswer) {
      console.log('Bonne r√©ponse');
      feedbackElement.textContent = '‚úÖ Bonne r√©ponse ! +1 point';
      feedbackElement.style.color = 'green';
      gameData.totalPoints++;
    } else {
      console.log('Mauvaise r√©ponse');
      feedbackElement.textContent = `‚ùå Faux ! La bonne r√©ponse √©tait "${expectedAnswer}" -1 point`;
      feedbackElement.style.color = 'red';
      
      // Enlever un point (mais ne pas descendre en dessous de 0)
      if (gameData.totalPoints > 0) {
        gameData.totalPoints--;
      }
      gameData.totalErreurs++;
      
      // Jouer un son d'erreur
      const sound = document.getElementById('sound-bad');
      if (sound) {
        sound.currentTime = 0;
        sound.play().catch(e => console.error('Erreur de lecture du son:', e));
      }
    }
    
    // Mettre √† jour le tableau des scores
    updateScoreboard(game);
    
    // D√©sactiver tous les boutons sauf suivant
    const buttons = document.querySelectorAll('.game-futur button');
    console.log('Boutons trouv√©s:', buttons.length);
    buttons.forEach(btn => {
      if (btn.id !== 'nextFutur') {
        btn.disabled = true;
      } else {
        btn.disabled = false;
      }
    });
    
    // Mettre √† jour le score
    if (window.updateScoreboard) {
      window.updateScoreboard(game);
    }
  }
  
  // Fonction pour charger les donn√©es du jeu futur depuis le fichier JSON
  function loadFuturData() {
    console.log('D√©but du chargement de futur.json...');
    return fetch('futur.json')
      .then(response => {
        console.log('R√©ponse re√ßue pour futur.json:', response.status, response.statusText);
        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status} ${response.statusText}`);
        }
        return response.json();
      })
      .then(data => {
        if (!data || !data.data || !Array.isArray(data.data)) {
          throw new Error('Format de donn√©es invalide dans futur.json');
        }
        console.log('Donn√©es brutes du futur charg√©es:', data);
        return data.data; // Retourne directement les donn√©es sans transformation
      })
      .catch(error => {
        console.error('Erreur lors du chargement des donn√©es du futur:', error);
      });
  }

  // Fonction pour charger les donn√©es du jeu roles
  async function loadRolesData() {
    console.log('D√©but du chargement de data.json...');
    try {
      const response = await fetch('data.json');
      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status} ${response.statusText}`);
      }
      const data = await response.json();
      console.log('Donn√©es du jeu roles charg√©es avec succ√®s');
      return data;
    } catch (error) {
      console.error('Erreur lors du chargement des donn√©es des r√¥les:', error);
      return [];
    }
  }

  // Fonction pour charger les donn√©es du jeu des temps
  async function loadTempsData() {
    console.log('D√©but du chargement de temps.json...');
    try {
      const response = await fetch('temps.json');
      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status} ${response.statusText}`);
      }
      const data = await response.json();
      console.log('Donn√©es du jeu des temps charg√©es avec succ√®s');
      return data.data || [];
    } catch (error) {
      console.error('Erreur lors du chargement des donn√©es des temps:', error);
      return [];
    }
  }

  // Fonction pour initialiser les jeux
  async function initGames() {
    if (!window.games) {
      // Initialiser la structure des jeux
      window.games = {
        roles: {
          data: [],
          current: 0,
          usedIndices: [],
          r√©ponsesCorrectes: new Set(),
          totalPoints: 0,
          totalErreurs: 0
        },
        futur: {
          data: [],
          current: 0,
          usedIndices: [],
          r√©ponsesCorrectes: new Set(),
          totalPoints: 0,
          totalErreurs: 0
        },
        temps: {
          data: [],
          current: 0,
          usedIndices: [],
          r√©ponsesCorrectes: new Set(),
          totalPoints: 0,
          totalErreurs: 0
        }
      };
      
      // Charger les donn√©es des jeux en parall√®le
      try {
        const [rolesData, futurData, tempsData] = await Promise.all([
          loadRolesData(),
          loadFuturData(),
          loadTempsData()
        ]);
        
        // Mettre √† jour les donn√©es des jeux
        if (rolesData && rolesData.length > 0) {
          window.games.roles.data = rolesData;
          console.log('Donn√©es du jeu roles charg√©es avec succ√®s');
        } else {
          console.warn('Aucune donn√©e charg√©e pour le jeu roles');
        }
        
        if (futurData && futurData.length > 0) {
          window.games.futur.data = futurData;
          console.log('Donn√©es du jeu futur charg√©es avec succ√®s');
        } else {
          console.warn('Aucune donn√©e charg√©e pour le jeu futur');
        }
        
        if (tempsData && tempsData.length > 0) {
          window.games.temps.data = tempsData;
          console.log('Donn√©es du jeu des temps charg√©es avec succ√®s');
        } else {
          console.warn('Aucune donn√©e charg√©e pour le jeu des temps');
        }
        
      } catch (error) {
        console.error('Erreur lors du chargement des donn√©es:', error);
      }
      
      console.log('Jeux initialis√©s avec succ√®s');
    }
  }
  
  // Fonction pour d√©marrer l'application une fois le DOM charg√©
  async function startApp() {
    console.log('D√©marrage de l\'application...');
    
    try {
      // Initialiser les jeux et attendre qu'ils soient pr√™ts
      await initGames();
      
      // V√©rifier que les jeux sont correctement initialis√©s
      if (!window.games) {
        throw new Error('√âchec de l\'initialisation des jeux');
      }
      
      console.log('Jeux initialis√©s avec succ√®s:', Object.keys(window.games));
      console.log('Donn√©es du jeu futur:', window.games?.futur?.data);
      
      // S√©lectionner le jeu par d√©faut (roles)
      selectGame('roles');
      
      // Afficher un message de chargement termin√©
      console.log('Application pr√™te');
      
    } catch (error) {
      console.error('Erreur lors du d√©marrage de l\'application:', error);
      // Afficher un message d'erreur √† l'utilisateur
      const errorDiv = document.createElement('div');
      errorDiv.style.color = 'red';
      errorDiv.style.padding = '20px';
      errorDiv.style.textAlign = 'center';
      errorDiv.textContent = 'Une erreur est survenue lors du chargement de l\'application. Veuillez rafra√Æchir la page.';
      document.body.insertBefore(errorDiv, document.body.firstChild);
    }
  }
  
  // D√©marrer l'application une fois le DOM charg√©
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', startApp);
  } else {
    startApp();
  }
  </script>
</head>
<body>
  <div class="container">
    <button class="menu-btn" onclick="toggleMenu()">‚ò∞</button>
    <nav class="sidebar">
      <div class="logo">
        <h2>R√©vision Grammaire</h2>
      </div>
      <ul class="menu">
        <li class="active">
          <a href="#roles" onclick="selectGame('roles')">
            <span>üîç R√¥les des groupes</span>
          </a>
        </li>
        <li>
          <a href="#futur" onclick="selectGame('futur')">
            <span>üîÆ Futur simple</span>
          </a>
        </li>
        <li>
          <a href="#temps" onclick="selectGame('temps')">
            <span>‚è±Ô∏è Les temps</span>
          </a>
        </li>
        <li>
          <a href="#conjugaison" onclick="selectGame('conjugaison')">
            <span>üìù Conjugaison au futur</span>
          </a>
        </li>
      </ul>
    </nav>
  <main class="main-content">
    <div class="top-bar">
      <div id="scoreboard">
        Points : <span id="points">0</span> | Erreurs : <span id="errors">0</span>
        <div class="stars" id="stars"></div>
      </div>
      <button onclick="resetScores()">üîÑ R√©initialiser</button>
    </div>

    <div class="game-content">
      <div class="game-roles">
        <h1>Quel est le r√¥le de chaque groupe ?</h1>
        <div class="phrase" id="phrase">Chargement de la phrase...</div>
        <div>
          <button onclick="checkAnswer('sujet')">üîµ Sujet</button>
          <button onclick="checkAnswer('verbe')">üî¥ Verbe</button>
          <button onclick="checkAnswer('cdv')">üî¥ GCDV</button>
          <button onclick="checkAnswer('civ')">üî¥ GCIV</button>
        </div>
        <p id="feedback"></p>
        <button id="nextBtn" onclick="nextPhrase()" disabled>üëâ Phrase suivante</button>
      </div>
      <div class="game-futur" style="display: none;">
        <h1>Conjugaison au futur simple</h1>
        <div class="futur-content">
          <div class="futur-phrase" id="futur-phrase">Chargement de la phrase...</div>
          <div>
            <button onclick="checkFutur('√™tre')">üîµ √™tre</button>
            <button onclick="checkFutur('avoir')">üî¥ avoir</button>
            <button onclick="checkFutur('er')">üîµ -er</button>
            <button onclick="checkFutur('ir')">üî¥ -ir</button>
          </div>
          <p id="futur-feedback"></p>
          <button id="nextFutur" onclick="nextPhrase('futur')" disabled>üëâ Phrase suivante</button>
        </div>
      </div>
      <div class="game-temps" style="display: none;">
        <h1>Analyse du verbe</h1>
        <div class="temps-content">
          <div class="temps-phrase" id="temps-phrase">Chargement de la phrase...</div>
          
          <div class="input-group">
            <label for="infinitif-input">Infinitif du verbe :</label>
            <input type="text" id="infinitif-input" placeholder="Entrez l'infinitif du verbe">
          </div>
          
          <div class="input-group">
            <label>Temps du verbe :</label>
            <div class="button-group">
              <button onclick="selectAndCheckTemps('pass√©')">‚èÆÔ∏è Pass√©</button>
              <button onclick="selectAndCheckTemps('pr√©sent')">‚èØÔ∏è Pr√©sent</button>
              <button onclick="selectAndCheckTemps('futur')">‚è≠Ô∏è Futur</button>
            </div>
          </div>
          
          <p id="temps-feedback"></p>
          <button id="nextTemps" onclick="nextPhrase('temps')" class="next-btn" disabled>üëâ Phrase suivante</button>
        </div>
      </div>

      <!-- Nouveau jeu de conjugaison au futur -->
      <div class="game-conjugaison" style="display: none;">
        <h1>Conjugaison au futur</h1>
        <div class="conjugaison-content">
          <div class="conjugaison-verbe" id="conjugaison-verbe">Conjuguez le verbe : <span id="verbe-infinitif">chargement...</span></div>
          
          <div class="conjugaison-grid">
            <div class="conjugaison-row">
              <label>Je</label>
              <input type="text" id="conj-je" data-personne="je" class="conjugaison-input">
              <span id="result-je" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Tu</label>
              <input type="text" id="conj-tu" data-personne="tu" class="conjugaison-input">
              <span id="result-tu" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Il/Elle/On</label>
              <input type="text" id="conj-il" data-personne="il" class="conjugaison-input">
              <span id="result-il" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Nous</label>
              <input type="text" id="conj-nous" data-personne="nous" class="conjugaison-input">
              <span id="result-nous" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Vous</label>
              <input type="text" id="conj-vous" data-personne="vous" class="conjugaison-input">
              <span id="result-vous" class="conjugaison-result"></span>
            </div>
            <div class="conjugaison-row">
              <label>Ils/Elles</label>
              <input type="text" id="conj-ils" data-personne="ils" class="conjugaison-input">
              <span id="result-ils" class="conjugaison-result"></span>
            </div>
          </div>
          
          <div class="conjugaison-actions">
            <button id="check-conjugaison" class="check-btn">V√©rifier les r√©ponses</button>
            <button id="next-conjugaison" class="next-btn" disabled>Verbe suivant</button>
          </div>
          
          <div id="conjugaison-feedback" class="conjugaison-feedback"></div>
        </div>
      </div>
    </div>
    <audio id="sound-bad" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg"></audio>
  </main>

<script>
let currentGame = 'roles'; // Game par d√©faut
let selected = null; // Variable pour stocker le mot s√©lectionn√©

// Variables pour le jeu de conjugaison
let currentVerbe = null;
let verbesData = [];
let currentVerbeIndex = 0;
let games = {
  roles: {
    data: [],
    current: 0,
    usedIndices: [],
    r√©ponsesCorrectes: new Set(),
    totalPoints: 0,
    totalErreurs: 0
  },
  futur: {
    data: [],
    current: 0,
    usedIndices: [],
    r√©ponsesCorrectes: new Set(),
    totalPoints: 0,
    totalErreurs: 0
  }
};

// Charger les donn√©es des r√¥les depuis le fichier JSON
fetch('./data.json')
  .then(response => response.json())
  .then(rolesData => {
    if (rolesData && Array.isArray(rolesData) && rolesData.length > 0) {
      games.roles.data = rolesData;
      selectGame('roles'); // Charger le jeu par d√©faut apr√®s le chargement des donn√©es
    } else {
      console.error('Donn√©es des r√¥les invalides ou manquantes');
      document.getElementById('phrase').textContent = 'Erreur : Donn√©es des r√¥les manquantes.';
    }
  })
  .catch(err => {
    console.error('Erreur de chargement des donn√©es des r√¥les:', err);
    document.getElementById('phrase').textContent = 'Erreur : Impossible de charger les donn√©es des r√¥les.';
  });

// Charger les donn√©es du futur depuis le fichier JSON
fetch('futur.json')
  .then(response => {
    if (!response.ok) {
      throw new Error(`Erreur HTTP: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    if (data && data.data && Array.isArray(data.data)) {
      games.futur.data = data.data;
      console.log('Donn√©es du futur charg√©es avec succ√®s:', games.futur.data);
    } else {
      throw new Error('Format de donn√©es invalide dans futur.json');
    }
  })
  .catch(error => {
    console.error('Erreur lors du chargement du fichier futur.json:', error);
  });

// Ajouter les gestionnaires d'√©v√©nements pour les boutons du futur
document.addEventListener('DOMContentLoaded', function() {
  console.log('Ajout des gestionnaires d\'√©v√©nements pour les boutons du futur');
  
  // Gestionnaire pour le bouton √™tre
  const btnEtre = document.querySelector('button[onclick*="checkFutur(\'√™tre\')"]');
  if (btnEtre) {
    console.log('Bouton √™tre trouv√©');
    btnEtre.onclick = function() { checkFutur('√™tre'); };
  }
  
  // Gestionnaire pour le bouton avoir
  const btnAvoir = document.querySelector('button[onclick*="checkFutur(\'avoir\')"]');
  if (btnAvoir) {
    console.log('Bouton avoir trouv√©');
    btnAvoir.onclick = function() { checkFutur('avoir'); };
  }
  
  // Gestionnaire pour le bouton -er
  const btnEr = document.querySelector('button[onclick*="checkFutur(\'er\')"]');
  if (btnEr) {
    console.log('Bouton -er trouv√©');
    btnEr.onclick = function() { checkFutur('er'); };
  }
  
  // Gestionnaire pour le bouton -ir
  const btnIr = document.querySelector('button[onclick*="checkFutur(\'ir\')"]');
  if (btnIr) {
    console.log('Bouton -ir trouv√©');
    btnIr.onclick = function() { checkFutur('ir'); };
  }
});

// Le chargement du jeu par d√©faut est maintenant g√©r√© dans startApp()

function selectGame(game) {
  // Fermer le menu sur mobile/tablette
  if (window.innerWidth <= 1024) {
    const sidebar = document.querySelector('.sidebar');
    if (sidebar) {
      sidebar.classList.remove('active');
    }
  }

  // Mettre √† jour le menu
  document.querySelectorAll('.menu li').forEach(li => {
    li.classList.remove('active');
    if (li.children[0].href.includes(`#${game}`)) {
      li.classList.add('active');
    }
  });

  // Cacher tous les jeux
  document.querySelectorAll('.game-content > div, .game-conjugaison').forEach(div => {
    div.style.display = 'none';
  });

  // Afficher le jeu s√©lectionn√©
  const gameDiv = document.querySelector(`.game-${game}`);
  if (gameDiv) {
    gameDiv.style.display = 'block';
  }

  // Mettre √† jour le jeu courant
  currentGame = game;

  // Charger le contenu appropri√© pour le jeu s√©lectionn√©
  if (game === 'roles') {
    renderPhrase('roles');
  } else if (game === 'futur') {
    renderPhrase('futur');
  } else if (game === 'temps') {
    renderPhrase('temps');
  } else if (game === 'conjugaison') {
    // Initialiser le jeu de conjugaison s'il n'est pas d√©j√† initialis√©
    if (verbesData.length === 0) {
      initConjugaison();
    }
  }
  
  // R√©initialiser les scores
  resetGame(game);
}

function resetGame(game = currentGame) {
  console.log(`R√©initialisation du jeu: ${game}`);
  
  const gameData = window.games?.[game];
  if (!gameData) {
    console.error('Impossible de r√©initialiser: jeu non trouv√©:', game);
    return;
  }
  
  // R√©initialiser les scores et l'√©tat
  gameData.totalPoints = 0;
  gameData.totalErreurs = 0;
  gameData.usedIndices = [];
  
  // Pour le jeu des r√¥les, r√©initialiser les r√©ponses correctes
  if (game === 'roles') {
    gameData.r√©ponsesCorrectes = new Set();
  }
  
  // S'assurer que current est d√©fini
  gameData.current = 0;
  
  console.log('Donn√©es du jeu apr√®s r√©initialisation:', gameData);
  
  // Choisir une phrase al√©atoire
  nextPhrase(game);
  
  // Mettre √† jour le score
  updateScoreboard(game);
  
  // R√©initialiser l'affichage
  if (game === 'futur') {
    const feedback = document.getElementById('futur-feedback');
    if (feedback) {
      feedback.textContent = '';
      feedback.style.color = '';
    }
  } else {
    const feedback = document.getElementById('feedback');
    if (feedback) {
      feedback.textContent = '';
    }
  }
  document.getElementById('nextBtn').disabled = true;
}

function updateScoreboard(game = currentGame) {
  if (!window.games || !window.games[game]) {
    console.error('Donn√©es du jeu non disponibles pour la mise √† jour du score');
    return;
  }
  
  const gameData = window.games[game];
  const pointsElement = document.getElementById('points');
  const errorsElement = document.getElementById('errors');
  const starsElement = document.getElementById('stars');
  
  if (pointsElement) pointsElement.textContent = gameData.totalPoints;
  if (errorsElement) errorsElement.textContent = gameData.totalErreurs;
  
  // Ajouter une √©toile par tranche de 10 points
  const starCount = Math.floor(Math.max(0, gameData.totalPoints) / 10);
  if (starsElement) {
    starsElement.textContent = '‚≠ê'.repeat(starCount);
    console.log(`Mise √† jour du score: ${gameData.totalPoints} points, ${starCount} √©toiles`);
  }
}

function renderPhrase(game = currentGame) {
  console.log(`Rendu de la phrase pour le jeu: ${game}`);
  
  if (!window.games) {
    console.error('Jeux non initialis√©s');
    return;
  }
  
  const gameData = window.games[game];
  if (!gameData) {
    console.error('Donn√©es du jeu non trouv√©es pour:', game, 'Disponibles:', Object.keys(window.games));
    return;
  }
  
  if (!gameData.data || !Array.isArray(gameData.data) || gameData.data.length === 0) {
    console.error('Aucune donn√©e de phrase disponible pour le jeu:', game);
    return;
  }
  
  if (typeof gameData.current === 'undefined' || !gameData.data[gameData.current]) {
    console.error('Index de phrase invalide:', gameData.current, 'pour le jeu:', game);
    return;
  }
  
  const phraseObj = gameData.data[gameData.current];
  console.log('Phrase actuelle:', phraseObj);
  
  // G√©rer le jeu des r√¥les
  if (game === 'roles') {
    const phraseTexte = phraseObj.phrase;
    let html = phraseTexte;
    document.getElementById('feedback').textContent = '';
    document.getElementById('nextBtn').disabled = true;
    gameData.r√©ponsesCorrectes = new Set();
    selected = null;

    // Remplace chaque groupe par un <span>
    if (phraseObj.groupes && Array.isArray(phraseObj.groupes)) {
      phraseObj.groupes.forEach((g, index) => {
        const escaped = g.texte.replace(/[.*+?^${}()|\\]/g, '\\$&');
        const pattern = new RegExp(escaped, 'i'); // ignore la casse
        html = html.replace(
          pattern,
          `<span class="mot" data-role="${g.role}" data-index="${index}">${g.texte}</span>`
        );
      });
    }

    const container = document.getElementById('phrase');
    container.innerHTML = html;

    container.querySelectorAll('.mot').forEach(span => {
      span.onclick = () => {
        if (span.classList.contains('bleu') || span.classList.contains('rouge')) return;
        document.querySelectorAll('.mot').forEach(m => m.classList.remove('selected'));
        selected = span;
        span.classList.add('selected');
        document.getElementById('feedback').textContent = '';
      };
    });
  }
  // G√©rer le jeu du futur simple
  else if (game === 'futur') {
    const container = document.getElementById('futur-phrase');
    if (!container) {
      console.error('√âl√©ment futur-phrase non trouv√©');
      return;
    }
    container.textContent = phraseObj.phrase || 'Phrase non disponible';
    
    const feedbackElement = document.getElementById('futur-feedback');
    if (feedbackElement) {
      feedbackElement.textContent = '';
      feedbackElement.style.color = '';
    }
    document.getElementById('nextFutur').disabled = true;
  }
  // G√©rer le jeu des temps
  else if (game === 'temps') {
    const container = document.getElementById('temps-phrase');
    if (!container) {
      console.error('√âl√©ment temps-phrase non trouv√©');
      return;
    }
    container.textContent = phraseObj.phrase || 'Phrase non disponible';
    
    const feedbackElement = document.getElementById('temps-feedback');
    if (feedbackElement) {
      feedbackElement.textContent = '';
      feedbackElement.style.color = '';
    }
    
    // R√©activer le champ de saisie et les boutons de r√©ponse
    const infinitifInput = document.getElementById('infinitif-input');
    if (infinitifInput) {
      infinitifInput.disabled = false;
      infinitifInput.value = ''; // R√©initialiser la valeur
    }
    
    // R√©activer les boutons de temps
    document.querySelectorAll('.game-temps .button-group button').forEach(btn => {
      btn.disabled = false;
    });
    
    // D√©s√©lectionner le temps pr√©c√©dent
    selectedTemps = null;
    
    // Les boutons de temps sont d√©j√† d√©sactiv√©s par d√©faut
    
    const nextBtn = document.getElementById('nextTemps');
    if (nextBtn) nextBtn.disabled = true;
  }
}

// La fonction checkFutur est maintenant d√©finie dans le <head> pour √™tre disponible imm√©diatement

function checkAnswer(answer, game = currentGame) {
  if (!selected) {
    alert("Clique sur un groupe de mots.");
    return;
  }

  const gameData = games[game];
  const role = selected.dataset.role;
  const idx = selected.dataset.index;
  selected.classList.remove('selected');

  if (answer === role) {
    selected.classList.add('bleu');
    document.getElementById('feedback').textContent = '‚úÖ Bonne r√©ponse !';
    gameData.r√©ponsesCorrectes.add(idx);
    gameData.totalPoints++;
  } else {
    selected.classList.add('rouge');
    document.getElementById('feedback').textContent = ' Mauvaise r√©ponse !';
    gameData.totalErreurs++;
    const sound = document.getElementById('sound-bad');
    sound.currentTime = 0;
    sound.play();
  }

  updateScoreboard(game);

  if (gameData.r√©ponsesCorrectes.size === gameData.data[gameData.current].groupes.length) {
    document.getElementById('nextBtn').disabled = false;
  }
}



function nextPhrase(game = currentGame) {
  if (!window.games) {
    console.error('Jeux non initialis√©s');
    return;
  }
  
  const gameData = window.games[game];
  if (!gameData) {
    console.error('Jeu non trouv√©:', game, 'Disponibles:', Object.keys(window.games));
    return;
  }
  
  console.log('Passage √† la phrase suivante. Indices utilis√©s:', gameData.usedIndices);
  
  // R√©activer les boutons de r√©ponse
  document.querySelectorAll('.game-futur button:not(#nextFutur)').forEach(btn => {
    btn.disabled = false;
  });
  
  // Si toutes les phrases ont √©t√© utilis√©es, r√©initialiser
  if (gameData.usedIndices.length >= gameData.data.length) {
    console.log('Toutes les phrases ont √©t√© utilis√©es, r√©initialisation...');
    gameData.usedIndices = [];
  }
  
  // Choisir une nouvelle phrase al√©atoire qui n'a pas encore √©t√© utilis√©e
  let newIndex;
  do {
    newIndex = Math.floor(Math.random() * gameData.data.length);
  } while (gameData.usedIndices.includes(newIndex) && gameData.usedIndices.length < gameData.data.length);
  
  console.log('Nouvel index choisi:', newIndex, 'sur', gameData.data.length - 1);
  
  // Mettre √† jour l'index actuel et l'ajouter aux indices utilis√©s
  gameData.current = newIndex;
  gameData.usedIndices.push(newIndex);
  
  console.log('Nouvelle phrase charg√©e:', gameData.data[gameData.current]);
  console.log('Index actuel apr√®s mise √† jour:', gameData.current);
  
  // Afficher la nouvelle phrase
  console.log('Appel de renderPhrase avec game:', game);
  renderPhrase(game);
  
  // D√©sactiver le bouton suivant jusqu'√† ce qu'une r√©ponse soit donn√©e
  if (game === 'futur') {
    const nextBtn = document.getElementById('nextFutur');
    if (nextBtn) nextBtn.disabled = true;
  } else {
    const nextBtn = document.getElementById('nextBtn');
    if (nextBtn) nextBtn.disabled = true;
  }
}

// Variables pour stocker la s√©lection de l'utilisateur
let selectedTemps = null;

// Fonction pour s√©lectionner un temps
function selectTemps(temps) {
  selectedTemps = temps;
  
  // Mettre √† jour le style des boutons
  document.querySelectorAll('.game-temps .button-group button').forEach(btn => {
    if (btn.textContent.includes(temps)) {
      btn.style.backgroundColor = '#4CAF50';
      btn.style.color = 'white';
    } else {
      btn.style.backgroundColor = '';
      btn.style.color = '';
    }
  });
  
  return document.getElementById('infinitif-input') && document.getElementById('infinitif-input').value.trim() !== '';
}

// Fonction pour s√©lectionner un temps et valider imm√©diatement
function selectAndCheckTemps(temps) {
  const isInfinitifValid = selectTemps(temps);
  
  if (!isInfinitifValid) {
    alert('Veuillez d\'abord entrer l\'infinitif du verbe');
    return;
  }
  
  checkTemps();
}

// Fonction pour v√©rifier la r√©ponse dans le jeu des temps
function checkTemps() {
  const game = 'temps';
  const infinitifInput = document.getElementById('infinitif-input');
  const userInfinitif = infinitifInput ? infinitifInput.value.trim().toLowerCase() : '';
  
  if (!selectedTemps) {
    alert('Veuillez s√©lectionner un temps');
    return;
  }
  
  if (!userInfinitif) {
    alert('Veuillez entrer l\'infinitif du verbe');
    return;
  }
  console.log('=== FONCTION checkTemps APPEL√âE ===');
  console.log('Temps choisi:', selectedTemps);
  
  if (!window.games) {
    console.error('L\'objet games n\'est pas encore charg√©');
    return;
  }
  
  // D√©sactiver les champs de saisie et les boutons
  if (infinitifInput) infinitifInput.disabled = true;
  document.querySelectorAll('.game-temps .button-group button').forEach(btn => {
    btn.disabled = true;
  });
  
  const gameData = window.games[game];
  if (!gameData) {
    console.error('Jeu non trouv√©:', game, 'Disponibles:', Object.keys(window.games));
    return;
  }
  
  const currentData = gameData.data[gameData.current];
  if (!currentData) {
    console.error('Aucune donn√©e pour la phrase actuelle');
    return;
  }
  
  const feedbackElement = document.getElementById('temps-feedback');
  const expectedAnswer = currentData.temps;
  const expectedInfinitif = currentData.infinitif.toLowerCase();
  
  console.log('R√©ponse attendue:', {
    temps: expectedAnswer,
    infinitif: expectedInfinitif
  }, 'R√©ponse donn√©e:', {
    temps: selectedTemps,
    infinitif: userInfinitif
  });
  
  const tempsCorrect = selectedTemps === expectedAnswer;
  const infinitifCorrect = userInfinitif === expectedInfinitif;
  
  if (tempsCorrect && infinitifCorrect) {
    console.log('Bonne r√©ponse pour le temps et l\'infinitif');
    feedbackElement.innerHTML = `‚úÖ Parfait ! ${expectedInfinitif} est bien au ${expectedAnswer}.<br>+1 point`;
    feedbackElement.style.color = 'green';
    gameData.totalPoints++;
  } else if (tempsCorrect && !infinitifCorrect) {
    console.log('Mauvaise r√©ponse pour l\'infinitif');
    feedbackElement.innerHTML = `‚ùå L'infinitif √©tait ${expectedInfinitif} (le temps √©tait correct).<br>-1 point`;
    feedbackElement.style.color = 'red';
    if (gameData.totalPoints > 0) gameData.totalPoints--;
    gameData.totalErreurs++;
  } else if (!tempsCorrect && infinitifCorrect) {
    console.log('Mauvaise r√©ponse pour le temps');
    feedbackElement.innerHTML = `‚ùå Le temps √©tait ${expectedAnswer} (l'infinitif √©tait correct).<br>-1 point`;
    feedbackElement.style.color = 'red';
    if (gameData.totalPoints > 0) gameData.totalPoints--;
    gameData.totalErreurs++;
  } else {
    console.log('Mauvaise r√©ponse pour le temps et l\'infinitif');
    feedbackElement.innerHTML = `‚ùå L'infinitif √©tait ${expectedInfinitif} et le temps √©tait ${expectedAnswer}.<br>-1 point`;
    feedbackElement.style.color = 'red';
    if (gameData.totalPoints > 0) gameData.totalPoints--;
    gameData.totalErreurs++;
    
    // Jouer un son d'erreur
    const errorSound = document.getElementById('error-sound');
    if (errorSound) {
      errorSound.play().catch(e => console.error('Erreur de lecture du son:', e));
    }
  }
  
  // Mettre √† jour le tableau des scores
  updateScoreboard(game);
  
  // D√©sactiver les boutons de r√©ponse et activer le bouton suivant
  document.querySelectorAll('.game-temps button:not(#nextTemps)').forEach(btn => {
    btn.disabled = true;
  });
  
  const nextBtn = document.getElementById('nextTemps');
  if (nextBtn) nextBtn.disabled = false;
}

// Fonction pour g√©rer le changement de jeu
function selectGame(game) {
  // Fermer le menu sur mobile/tablette
  if (window.innerWidth <= 1024) {
    const sidebar = document.querySelector('.sidebar');
    if (sidebar) {
      sidebar.classList.remove('active');
    }
  }

  // Mettre √† jour le menu
  document.querySelectorAll('.menu li').forEach(li => {
    li.classList.remove('active');
    if (li.children[0].href.includes(`#${game}`)) {
      li.classList.add('active');
    }
  });

  // Cacher tous les jeux
  document.querySelectorAll('.game-content > div').forEach(div => {
    div.style.display = 'none';
  });

  // Afficher le jeu s√©lectionn√©
  const gameDiv = document.querySelector(`.game-${game}`);
  if (gameDiv) {
    gameDiv.style.display = 'block';
  } else {
    console.error('√âl√©ment du jeu non trouv√©:', `.game-${game}`);
  }

  // R√©initialiser les scores
  resetGame(game);
}

// Fonction pour g√©rer le menu hamburger
function toggleMenu() {
  const sidebar = document.querySelector('.sidebar');
  const menuBtn = document.querySelector('.menu-btn');
  
  if (sidebar.style.left === '0px' || !sidebar.style.left) {
    sidebar.style.left = '-250px';
    menuBtn.textContent = '‚ò∞';
    menuBtn.style.left = '10px';
  } else {
    sidebar.style.left = '0';
    menuBtn.textContent = '‚úï';
    menuBtn.style.left = '260px';
  }
}

// Fonction utilitaire pour m√©langer un tableau
function shuffleArray(array) {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
}

// Afficher le prochain verbe √† conjuguer
function nextVerbe() {
  if (!verbesData || verbesData.length === 0) {
    const element = document.getElementById('conjugaison-verbe');
    if (element) element.textContent = 'Tous les verbes ont √©t√© utilis√©s !';
    const checkBtn = document.getElementById('check-conjugaison');
    if (checkBtn) checkBtn.disabled = true;
    return;
  }
  
  // Prendre le premier verbe de la liste
  currentVerbe = verbesData.shift();
  const verbeElement = document.getElementById('verbe-infinitif');
  if (verbeElement) verbeElement.textContent = currentVerbe.infinitif;
  
  // R√©initialiser les champs
  document.querySelectorAll('.conjugaison-input').forEach(input => {
    input.value = '';
    input.disabled = false;
    input.classList.remove('correct', 'incorrect');
  });
  
  // R√©initialiser les r√©sultats
  document.querySelectorAll('.conjugaison-result').forEach(span => {
    span.textContent = '';
  });
  
  // R√©initialiser le feedback
  const feedback = document.getElementById('conjugaison-feedback');
  if (feedback) feedback.textContent = '';
  
  // D√©sactiver le bouton suivant
  const nextBtn = document.getElementById('next-conjugaison');
  if (nextBtn) nextBtn.disabled = true;
  
  // Activer le bouton de v√©rification
  const checkBtn = document.getElementById('check-conjugaison');
  if (checkBtn) checkBtn.disabled = false;
}

// V√©rifier les r√©ponses
function checkConjugaison() {
  if (!currentVerbe) return;
  
  let score = 0;
  const personnes = ['je', 'tu', 'il', 'nous', 'vous', 'ils'];
  
  personnes.forEach(personne => {
    const input = document.getElementById(`conj-${personne}`);
    const resultSpan = document.getElementById(`result-${personne}`);
    if (!input || !resultSpan) return;
    
    const reponse = input.value.trim().toLowerCase();
    const bonneReponse = currentVerbe.conjugaisons[personne];
    
    if (reponse === bonneReponse) {
      input.classList.add('correct');
      input.classList.remove('incorrect');
      resultSpan.textContent = '‚úì';
      resultSpan.className = 'conjugaison-result correct';
      score++;
    } else {
      input.classList.add('incorrect');
      input.classList.remove('correct');
      resultSpan.textContent = bonneReponse;
      resultSpan.className = 'conjugaison-result incorrect';
    }
    
    // D√©sactiver le champ apr√®s v√©rification
    input.disabled = true;
  });
  
  // Afficher le score
  const scoreText = `Score : ${score}/6`;
  const feedback = document.getElementById('conjugaison-feedback');
  if (feedback) {
    feedback.textContent = score === 6 
      ? `‚úÖ Parfait ! ${scoreText}` 
      : `‚ùå ${scoreText} - Essayez encore ou passez au verbe suivant`;
  }
  
  // Activer le bouton suivant
  const nextBtn = document.getElementById('next-conjugaison');
  if (nextBtn) nextBtn.disabled = false;
  
  // D√©sactiver le bouton de v√©rification
  const checkBtn = document.getElementById('check-conjugaison');
  if (checkBtn) checkBtn.disabled = true;
}

// Initialiser le jeu de conjugaison
async function initConjugaison() {
  try {
    const response = await fetch('futur-conjugaison.json');
    const data = await response.json();
    verbesData = data.verbes;
    // M√©langer les verbes pour plus de vari√©t√©
    verbesData = shuffleArray([...verbesData]);
    // Charger le premier verbe
    nextVerbe();
  } catch (error) {
    console.error('Erreur lors du chargement des verbes:', error);
    const element = document.getElementById('conjugaison-verbe');
    if (element) element.textContent = 'Erreur de chargement des verbes';
  }
}

// Ajouter les √©couteurs d'√©v√©nements pour le jeu de conjugaison
document.addEventListener('DOMContentLoaded', function() {
  const checkBtn = document.getElementById('check-conjugaison');
  const nextBtn = document.getElementById('next-conjugaison');
  
  if (checkBtn) {
    checkBtn.addEventListener('click', checkConjugaison);
  }
  
  if (nextBtn) {
    nextBtn.addEventListener('click', nextVerbe);
  }
  
  // Valider la conjugaison avec la touche Entr√©e
  document.querySelectorAll('.conjugaison-input').forEach(input => {
    input.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        checkConjugaison();
      }
    });
  });
  
  // Initialiser le jeu de conjugaison
  initConjugaison();
});
</script>
</body>
</html>
